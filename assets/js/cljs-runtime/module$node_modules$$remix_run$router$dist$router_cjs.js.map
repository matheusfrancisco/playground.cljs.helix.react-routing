{
"version":3,
"file":"module$node_modules$$remix_run$router$dist$router_cjs.js",
"lineCount":165,
"mappings":"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",
"sources":["node_modules/@remix-run/router/dist/router.cjs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$remix_run$router$dist$router_cjs\"] = function(global,require,module,exports) {\n/**\n * @remix-run/router v1.13.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Actions represent the type of change to a location value.\n */\nlet Action = /*#__PURE__*/function (Action) {\n  Action[\"Pop\"] = \"POP\";\n  Action[\"Push\"] = \"PUSH\";\n  Action[\"Replace\"] = \"REPLACE\";\n  return Action;\n}({});\n\n/**\n * The pathname, search, and hash values of a URL.\n */\n\n// TODO: (v7) Change the Location generic default from `any` to `unknown` and\n// remove Remix `useLocation` wrapper.\n/**\n * An entry in a history stack. A location contains information about the\n * URL path, as well as possibly some arbitrary state and a key.\n */\n/**\n * A change to the current location.\n */\n/**\n * A function that receives notifications about location changes.\n */\n/**\n * Describes a location that is the destination of some navigation, either via\n * `history.push` or `history.replace`. This may be either a URL or the pieces\n * of a URL path.\n */\n/**\n * A history is an interface to the navigation stack. The history serves as the\n * source of truth for the current location, as well as provides a set of\n * methods that may be used to change it.\n *\n * It is similar to the DOM's `window.history` object, but with a smaller, more\n * focused API.\n */\nconst PopStateEventType = \"popstate\";\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Memory History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A user-supplied object that describes a location. Used when providing\n * entries to `createMemoryHistory` via its `initialEntries` option.\n */\n/**\n * A memory history stores locations in memory. This is useful in stateful\n * environments where there is no web browser, such as node tests or React\n * Native.\n */\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    initialEntries = [\"/\"],\n    initialIndex,\n    v5Compat = false\n  } = options;\n  let entries; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  let action = Action.Pop;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta\n        });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Browser History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A browser history stores the current location in regular URLs in a web\n * browser environment. This is the standard for most web apps and provides the\n * cleanest URLs the browser's address bar.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory\n */\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window, globalHistory) {\n    let {\n      pathname,\n      search,\n      hash\n    } = window.location;\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createBrowserHref(window, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Hash History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hash history stores the current location in the fragment identifier portion\n * of the URL in a web browser environment.\n *\n * This is ideal for apps that do not control the server for some reason\n * (because the fragment identifier is never sent to the server), including some\n * shared hosting environments that do not provide fine-grained controls over\n * which pages are served at which URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory\n */\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window.location.hash.substr(1));\n\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path=\"*\">) since that matches internally against\n    // \"/*\" and we'd expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createHashHref(window, to) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region UTILS\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @private\n */\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\n\n/**\n * Creates a Location object with a unique key from the given Path\n */\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  let location = _extends({\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\"\n  }, typeof to === \"string\" ? parsePath(to) : to, {\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\n\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nfunction createPath(_ref) {\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\"\n  } = _ref;\n  if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    window = document.defaultView,\n    v5Compat = false\n  } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex();\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base = window.location.origin !== \"null\" ? window.location.origin : window.location.href;\n    let href = typeof to === \"string\" ? to : createPath(to);\n    invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\n\n//#endregion\n\n/**\n * Map of routeId -> data returned from a loader/action/error\n */\n\nlet ResultType = /*#__PURE__*/function (ResultType) {\n  ResultType[\"data\"] = \"data\";\n  ResultType[\"deferred\"] = \"deferred\";\n  ResultType[\"redirect\"] = \"redirect\";\n  ResultType[\"error\"] = \"error\";\n  return ResultType;\n}({});\n\n/**\n * Successful result from a loader or action\n */\n\n/**\n * Successful defer() result from a loader or action\n */\n\n/**\n * Redirect result from a loader or action\n */\n\n/**\n * Unsuccessful result from a loader or action\n */\n\n/**\n * Result from a loader or action - potentially successful or unsuccessful\n */\n\n/**\n * Users can specify either lowercase or uppercase form methods on `<Form>`,\n * useSubmit(), `<fetcher.Form>`, etc.\n */\n\n/**\n * Active navigation/fetcher form methods are exposed in lowercase on the\n * RouterState\n */\n\n/**\n * In v7, active navigation/fetcher form methods are exposed in uppercase on the\n * RouterState.  This is to align with the normalization done via fetch().\n */\n\n// Thanks https://github.com/sindresorhus/type-fest!\n\n/**\n * @private\n * Internal interface to pass around for action submissions, not intended for\n * external consumption\n */\n\n/**\n * @private\n * Arguments passed to route loader/action functions.  Same for now but we keep\n * this as a private implementation detail in case they diverge in the future.\n */\n\n// TODO: (v7) Change the defaults from any to unknown in and remove Remix wrappers:\n//   ActionFunction, ActionFunctionArgs, LoaderFunction, LoaderFunctionArgs\n//   Also, make them a type alias instead of an interface\n/**\n * Arguments passed to loader functions\n */\n/**\n * Arguments passed to action functions\n */\n/**\n * Loaders and actions can return anything except `undefined` (`null` is a\n * valid return value if there is no data to return).  Responses are preferred\n * and will ease any future migration to Remix\n */\n/**\n * Route loader function signature\n */\n/**\n * Route action function signature\n */\n/**\n * Arguments passed to shouldRevalidate function\n */\n/**\n * Route shouldRevalidate function signature.  This runs after any submission\n * (navigation or fetcher), so we flatten the navigation/fetcher submission\n * onto the arguments.  It shouldn't matter whether it came from a navigation\n * or a fetcher, what really matters is the URLs and the formData since loaders\n * have to re-run based on the data models that were potentially mutated.\n */\n/**\n * Function provided by the framework-aware layers to set `hasErrorBoundary`\n * from the framework-aware `errorElement` prop\n *\n * @deprecated Use `mapRouteProperties` instead\n */\n/**\n * Function provided by the framework-aware layers to set any framework-specific\n * properties from framework-agnostic properties\n */\n/**\n * Keys we cannot change from within a lazy() function. We spread all other keys\n * onto the route. Either they're meaningful to the router, or they'll get\n * ignored.\n */\nconst immutableRouteKeys = new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\n\n/**\n * lazy() function to load a route definition, which can add non-matching\n * related properties to a route\n */\n\n/**\n * Base RouteObject with common props shared by all types of routes\n */\n\n/**\n * Index routes must not have children\n */\n\n/**\n * Non-index routes may have children, but cannot have index\n */\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\n\n/**\n * A data route object, which is just a RouteObject with a required unique ID\n */\n\n// Recursive helper for finding path parameters in the absence of wildcards\n\n/**\n * Examples:\n * \"/a/b/*\" -> \"*\"\n * \":a\" -> \"a\"\n * \"/a/:b\" -> \"b\"\n * \"/a/blahblahblah:b\" -> \"b\"\n * \"/:a/:b\" -> \"a\" | \"b\"\n * \"/:a/b/:c/*\" -> \"a\" | \"c\" | \"*\"\n */\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise, return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\n/**\n * The parameters that were parsed from the URL path.\n */\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\n\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n    invariant(!manifest[id], \"Found a route id collision on id \\\"\" + id + \"\\\".  Route \" + \"id's must be globally unique within Data Router usages\");\n    if (isIndexRoute(route)) {\n      let indexRoute = _extends({}, route, mapRouteProperties(route), {\n        id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n        id,\n        children: undefined\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = \"/\";\n  }\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i],\n    // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won't be\n    // encoded here but there also shouldn't be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    safelyDecodeURI(pathname));\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let {\n    route,\n    pathname,\n    params\n  } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(meta.relativePath.startsWith(parentPath), \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n      // Our types know better, but runtime JS may not!\n      // @ts-expect-error\n      route.index !== true, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\"));\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    var _route$path;\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\n\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n  let [first, ...rest] = segments;\n\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(...restExploded.map(subpath => subpath === \"\" ? required : [required, subpath].join(\"/\")));\n\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map(exploded => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first\n  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));\n}\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ?\n  // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] :\n  // Otherwise, it doesn't really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\nfunction matchRouteBranch(branch, pathname) {\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    if (!match) return null;\n    Object.assign(matchedParams, match.params);\n    let route = meta.route;\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(false, \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n    path = path.replace(/\\*$/, \"/*\");\n  }\n\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify = p => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n\n    // only apply the splat if it's the last segment\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      // Apply the splat\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, \"Missing \\\":\" + key + \"\\\" param\");\n      return stringify(param);\n    }\n\n    // Remove any optional markers from optional static segments\n    return segment.replace(/\\?$/g, \"\");\n  })\n  // Remove empty segments\n  .filter(segment => !!segment);\n  return prefix + segments.join(\"/\");\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = compiledParams.reduce((memo, _ref, index) => {\n    let {\n      paramName,\n      isOptional\n    } = _ref;\n    // We need to compute the pathnameBase here using the raw splat value\n    // instead of using params[\"*\"] later because it will be decoded then\n    if (paramName === \"*\") {\n      let splatValue = captureGroups[index] || \"\";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n    }\n    const value = captureGroups[index];\n    if (isOptional && !value) {\n      memo[paramName] = undefined;\n    } else {\n      memo[paramName] = safelyDecodeURIComponent(value || \"\", paramName);\n    }\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n  let params = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n  .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n  .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n  .replace(/\\/:(\\w+)(\\?)?/g, (_, paramName, isOptional) => {\n    params.push({\n      paramName,\n      isOptional: isOptional != null\n    });\n    return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n  });\n  if (path.endsWith(\"*\")) {\n    params.push({\n      paramName: \"*\"\n    });\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n    : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else ;\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n  return [matcher, params];\n}\nfunction safelyDecodeURI(value) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(false, \"The URL path \\\"\" + value + \"\\\" could not be decoded because it is is a \" + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n    return value;\n  }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\"));\n    return value;\n  }\n}\n\n/**\n * @private\n */\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach(segment => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + \"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";\n}\n\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nfunction getPathContributingMatches(matches) {\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\n}\n\n/**\n * @private\n */\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n    invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n    invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (toPathname == null) {\n    from = locationPathname;\n  } else if (isPathRelative) {\n    let fromSegments = routePathnames[routePathnames.length - 1].replace(/^\\//, \"\").split(\"/\");\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // With relative=\"path\", each leading .. segment means \"go up one URL segment\"\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        fromSegments.pop();\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = \"/\" + fromSegments.join(\"/\");\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // With relative=\"route\" (the default), each leading .. segment means\n      // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n      // difference from how <a href> works and a major reason we call this a\n      // \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\n\n/**\n * @private\n */\nfunction getToPathname(to) {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n\n/**\n * @private\n */\nconst joinPaths = paths => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\n/**\n * @private\n */\nconst normalizePathname = pathname => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\n/**\n * @private\n */\nconst normalizeSearch = search => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n\n/**\n * @private\n */\nconst normalizeHash = hash => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nconst json = function json(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers\n  }));\n};\nclass AbortedDeferredError extends Error {}\nclass DeferredData {\n  constructor(data, responseInit) {\n    this.pendingKeysSet = new Set();\n    this.subscribers = new Set();\n    this.deferredKeys = [];\n    invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject;\n    this.abortPromise = new Promise((_, r) => reject = r);\n    this.controller = new AbortController();\n    let onAbort = () => reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n    this.data = Object.entries(data).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      return Object.assign(acc, {\n        [key]: this.trackPromise(key, value)\n      });\n    }, {});\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  trackPromise(key, value) {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));\n\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n    Object.defineProperty(promise, \"_tracked\", {\n      get: () => true\n    });\n    return promise;\n  }\n  onSettle(promise, key, error, data) {\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      return Promise.reject(error);\n    }\n    this.pendingKeysSet.delete(key);\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error(\"Deferred data for key \\\"\" + key + \"\\\" resolved/rejected with `undefined`, \" + \"you must resolve/reject with a value or `null`.\");\n      Object.defineProperty(promise, \"_error\", {\n        get: () => undefinedError\n      });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n    if (data === undefined) {\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n    Object.defineProperty(promise, \"_data\", {\n      get: () => data\n    });\n    this.emit(false, key);\n    return data;\n  }\n  emit(aborted, settledKey) {\n    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));\n  }\n  subscribe(fn) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n  async resolveData(signal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise(resolve => {\n        this.subscribe(aborted => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n  get unwrappedData() {\n    invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n    return Object.entries(this.data).reduce((acc, _ref3) => {\n      let [key, value] = _ref3;\n      return Object.assign(acc, {\n        [key]: unwrapTrackedPromise(value)\n      });\n    }, {});\n  }\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\nconst defer = function defer(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst redirect = function redirect(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers\n  }));\n};\n\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */\nclass ErrorResponseImpl {\n  constructor(status, statusText, data, internal) {\n    if (internal === void 0) {\n      internal = false;\n    }\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A Router instance manages all navigation and data loading/mutations\n */\n/**\n * State maintained internally by the router.  During a navigation, all states\n * reflect the the \"old\" location unless otherwise noted.\n */\n/**\n * Data that can be passed into hydrate a Router from SSR\n */\n/**\n * Future flags to toggle new feature behavior\n */\n/**\n * Initialization options for createRouter\n */\n/**\n * State returned from a server-side query() call\n */\n/**\n * A StaticHandler instance manages a singular SSR navigation/fetch event\n */\n/**\n * Subscriber function signature for changes to router state\n */\n/**\n * Function signature for determining the key to be used in scroll restoration\n * for a given location\n */\n/**\n * Function signature for determining the current scroll position\n */\n// Allowed for any navigation or fetch\n// Only allowed for navigations\n// Only allowed for submission navigations\n/**\n * Options for a navigate() call for a normal (non-submission) navigation\n */\n/**\n * Options for a navigate() call for a submission navigation\n */\n/**\n * Options to pass to navigate() for a navigation\n */\n/**\n * Options for a fetch() load\n */\n/**\n * Options for a fetch() submission\n */\n/**\n * Options to pass to fetch()\n */\n/**\n * Potential states for state.navigation\n */\n/**\n * Potential states for fetchers\n */\n/**\n * Cached info for active fetcher.load() instances so they can participate\n * in revalidation\n */\n/**\n * Identified fetcher.load() calls that need to be revalidated\n */\n/**\n * Wrapper object to allow us to throw any response out from callLoaderOrAction\n * for queryRouter while preserving whether or not it was thrown or returned\n * from the loader/action\n */\nconst validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = [\"get\", ...validMutationMethodsArr];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\nconst IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_FETCHER = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = route => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Create a router and listen to history POP navigations\n */\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : undefined;\n  const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser;\n  invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n  let mapRouteProperties;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n\n  // Routes keyed by ID\n  let manifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  // Config driven behavior flags\n  let future = _extends({\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_prependBasename: false\n  }, init.future);\n  // Cleanup function for history\n  let unlistenHistory = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors = null;\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = {\n      [route.id]: error\n    };\n  }\n  let initialized =\n  // All initialMatches need to be loaded before we're ready.  If we have lazy\n  // functions around still then we'll need to run them in initialize()\n  !initialMatches.some(m => m.route.lazy) && (\n  // And we have to either have no loaders or have been provided hydrationData\n  !initialMatches.some(m => m.route.loader) || init.hydrationData != null);\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map()\n  };\n\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction = Action.Pop;\n\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n\n  // AbortController for the active navigation\n  let pendingNavigationController;\n\n  // Should the current navigation enable document.startViewTransition?\n  let pendingViewTransitionEnabled = false;\n\n  // Store applied view transitions so we can apply them on POP\n  let appliedViewTransitions = new Map();\n\n  // Cleanup function for persisting applied transitions to sessionStorage\n  let removePageHideEventListener = null;\n\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes = [];\n\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads = [];\n\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map();\n\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map();\n\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set();\n\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map();\n\n  // Ref-count mounted fetchers so we know when it's ok to clean them up\n  let activeFetchers = new Map();\n\n  // Fetchers that have requested a delete when using v7_fetcherPersist,\n  // they'll be officially removed after they return to idle\n  let deletedFetchers = new Set();\n\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map();\n\n  // Store blocker functions in a separate Map outside of router state since\n  // we don't need to update UI state if they change\n  let blockerFunctions = new Map();\n\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(_ref => {\n      let {\n        action: historyAction,\n        location,\n        delta\n      } = _ref;\n      // Ignore this event if it was just us resetting the URL from a\n      // blocked POP navigation\n      if (ignoreNextHistoryUpdate) {\n        ignoreNextHistoryUpdate = false;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n      let blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction\n      });\n      if (blockerKey && delta != null) {\n        // Restore the URL to match the current UI, but don't update router state\n        ignoreNextHistoryUpdate = true;\n        init.history.go(delta * -1);\n\n        // Put the blocker into a blocked state\n        updateBlocker(blockerKey, {\n          state: \"blocked\",\n          location,\n          proceed() {\n            updateBlocker(blockerKey, {\n              state: \"proceeding\",\n              proceed: undefined,\n              reset: undefined,\n              location\n            });\n            // Re-do the same POP navigation we just blocked\n            init.history.go(delta);\n          },\n          reset() {\n            let blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    if (isBrowser) {\n      // FIXME: This feels gross.  How can we cleanup the lines between\n      // scrollRestoration/appliedTransitions persistance?\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\n    // resolved prior to router creation since we can't go into a fallbackElement\n    // UI for SSR'd apps\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location);\n    }\n    return router;\n  }\n\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n\n  // Subscribe to state updates for the router\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n\n  // Update our state and notify the calling context of the change\n  function updateState(newState, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state = _extends({}, state, newState);\n\n    // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n    // can be removed\n    let completedFetchers = [];\n    let deletedFetchersKeys = [];\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach((fetcher, key) => {\n        if (fetcher.state === \"idle\") {\n          if (deletedFetchers.has(key)) {\n            // Unmounted from the UI and can be totally removed\n            deletedFetchersKeys.push(key);\n          } else {\n            // Returned to idle but still mounted in the UI, so semi-remains for\n            // revalidations and such\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n\n    // Iterate over a local copy so that if flushSync is used and we end up\n    // removing and adding a new subscriber due to the useCallback dependencies,\n    // we don't get ourselves into a loop calling the new subscriber immediately\n    [...subscribers].forEach(subscriber => subscriber(state, {\n      deletedFetchers: deletedFetchersKeys,\n      unstable_viewTransitionOpts: opts.viewTransitionOpts,\n      unstable_flushSync: opts.flushSync === true\n    }));\n\n    // Remove idle fetchers from state since we only care about in-flight fetchers.\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach(key => state.fetchers.delete(key));\n      deletedFetchersKeys.forEach(key => deleteFetcher(key));\n    }\n  }\n\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(location, newState, _temp) {\n    var _location$state, _location$state2;\n    let {\n      flushSync\n    } = _temp === void 0 ? {} : _temp;\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n\n    // Always respect the user flag.  Otherwise don't reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n    if (isUninterruptedRevalidation) ; else if (pendingAction === Action.Pop) ; else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    let viewTransitionOpts;\n\n    // On POP, enable transitions if they were enabled on the original navigation\n    if (pendingAction === Action.Pop) {\n      // Forward takes precedence so they behave like the original navigation\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        // If we don't have a previous forward nav, assume we're popping back to\n        // the new location and enable if that location previously enabled\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      // Store the applied transition on PUSH/REPLACE\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(_extends({}, newState, {\n      // matches, errors, fetchers go through as-is\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset,\n      blockers\n    }), {\n      viewTransitionOpts,\n      flushSync: flushSync === true\n    });\n\n    // Reset stateful navigation vars\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n    let historyAction = Action.Push;\n    if (userReplace === true) {\n      historyAction = Action.Replace;\n    } else if (userReplace === false) ; else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = Action.Replace;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({\n            blockers\n          });\n        }\n      });\n      return;\n    }\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.unstable_viewTransition,\n      flushSync\n    });\n  }\n\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: \"loading\"\n    });\n\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation\n    });\n  }\n\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(historyAction, location, opts) {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error\n        }\n      }, {\n        flushSync\n      });\n      return;\n    }\n\n    // Short circuit if it's only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n    // which will default to a navigation to /page\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, {\n        matches\n      }, {\n        flushSync\n      });\n      return;\n    }\n\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n    let pendingActionData;\n    let pendingError;\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError\n      };\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      // Call action if we received an action submission\n      let actionOutput = await handleAction(request, location, opts.submission, matches, {\n        replace: opts.replace,\n        flushSync\n      });\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n\n      // Create a GET request for the loaders\n      request = new Request(request.url, {\n        signal: request.signal\n      });\n    }\n\n    // Call loaders\n    let {\n      shortCircuited,\n      loaderData,\n      errors\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, flushSync, pendingActionData, pendingError);\n    if (shortCircuited) {\n      return;\n    }\n\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n    completeNavigation(location, _extends({\n      matches\n    }, pendingActionData ? {\n      actionData: pendingActionData\n    } : {}, {\n      loaderData,\n      errors\n    }));\n  }\n\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(request, location, submission, matches, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    interruptActiveLoads();\n\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({\n      navigation\n    }, {\n      flushSync: opts.flushSync === true\n    });\n\n    // Call our action and get the result\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename);\n      if (request.signal.aborted) {\n        return {\n          shortCircuited: true\n        };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        replace = result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, {\n        submission,\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = Action.Push;\n      }\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: {\n          [boundaryMatch.route.id]: result.error\n        }\n      };\n    }\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    return {\n      pendingActionData: {\n        [actionMatch.route.id]: result.data\n      }\n    };\n  }\n\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, flushSync, pendingActionData, pendingError) {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));\n    pendingNavigationLoadId = ++incrementingLoadId;\n\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(location, _extends({\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingError || null\n      }, pendingActionData ? {\n        actionData: pendingActionData\n      } : {}, updatedFetchers ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    if (!isUninterruptedRevalidation) {\n      revalidatingFetchers.forEach(rf => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState(_extends({\n        navigation: loadingNavigation\n      }, actionData ? Object.keys(actionData).length === 0 ? {\n        actionData: null\n      } : {\n        actionData\n      } : {}, revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n    }\n    revalidatingFetchers.forEach(rf => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n    if (request.signal.aborted) {\n      return {\n        shortCircuited: true\n      };\n    }\n\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));\n\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect.result, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe(aborted => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return _extends({\n      loaderData,\n      errors\n    }, shouldUpdateFetchers ? {\n      fetchers: new Map(state.fetchers)\n    } : {});\n  }\n\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n    }\n    if (fetchControllers.has(key)) abortFetcher(key);\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }), {\n        flushSync\n      });\n      return;\n    }\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n    if (error) {\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n      return;\n    }\n\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, {\n      routeId,\n      path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n  }\n\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId\n      });\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync\n    });\n\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(undefined));\n      return;\n    }\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our action started, so that\n        // should take precedence over this redirect navigation.  We already\n        // set isRevalidationRequired so all loaders for the new route should\n        // fire unless opted out via shouldRevalidate\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        updateFetcherState(key, getLoadingFetcher(submission));\n        return startRedirectNavigation(state, actionResult, {\n          fetcherSubmission: submission\n        });\n      }\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n      [match.route.id]: actionResult.data\n    }, undefined // No need to send through errors since we short circuit above\n    );\n\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {\n      let staleKey = rf.key;\n      let existingFetcher = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      if (fetchControllers.has(staleKey)) {\n        abortFetcher(staleKey);\n      }\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect.result);\n    }\n\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn't been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    abortStaleFetchLoads(loadId);\n\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n        fetchers: new Map(state.fetchers)\n      });\n      isRevalidationRequired = false;\n    }\n  }\n\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\n      flushSync\n    });\n\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties, basename);\n\n    // Deferred isn't supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;\n    }\n\n    // We can delete this so long as we weren't aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(undefined));\n      return;\n    }\n\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n\n    // Put the fetcher back into an idle state\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(state, redirect, _temp2) {\n    let {\n      submission,\n      fetcherSubmission,\n      replace\n    } = _temp2 === void 0 ? {} : _temp2;\n    if (redirect.revalidate) {\n      isRevalidationRequired = true;\n    }\n    let redirectLocation = createLocation(state.location, redirect.location, {\n      _isRedirect: true\n    });\n    invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n    if (isBrowser) {\n      let isDocumentReload = false;\n      if (redirect.reloadDocument) {\n        // Hard reload if the response contained X-Remix-Reload-Document\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n        const url = init.history.createURL(redirect.location);\n        isDocumentReload =\n        // Hard reload if it's an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin ||\n        // Hard reload if it's an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(redirect.location);\n        } else {\n          routerWindow.location.assign(redirect.location);\n        }\n        return;\n      }\n    }\n\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let {\n      formMethod,\n      formAction,\n      formEncType\n    } = state.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: _extends({}, activeSubmission, {\n          formAction: redirect.location\n        }),\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    } else {\n      // If we have a navigation submission, we will preserve it through the\n      // redirect navigation\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    }\n  }\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\n    // then slice off the results into separate arrays so we can handle them\n    // accordingly\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename)), ...fetchersToLoad.map(f => {\n      if (f.matches && f.match && f.controller) {\n        return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename);\n      } else {\n        let error = {\n          type: ResultType.error,\n          error: getInternalRouterError(404, {\n            pathname: f.path\n          })\n        };\n        return error;\n      }\n    })]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, fetchersToLoad.map(f => f.controller ? f.controller.signal : null), true)]);\n    return {\n      results,\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n  function updateFetcherState(key, fetcher, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function setFetcherError(key, routeId, error, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error\n      },\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function getFetcher(key) {\n    if (future.v7_fetcherPersist) {\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n      // If this fetcher was previously marked for deletion, unmark it since we\n      // have a new instance\n      if (deletedFetchers.has(key)) {\n        deletedFetchers.delete(key);\n      }\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\n    // in it's loading phase since - we don't want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    deletedFetchers.delete(key);\n    state.fetchers.delete(key);\n  }\n  function deleteFetcherAndUpdateState(key) {\n    if (future.v7_fetcherPersist) {\n      let count = (activeFetchers.get(key) || 0) - 1;\n      if (count <= 0) {\n        activeFetchers.delete(key);\n        deletedFetchers.add(key);\n      } else {\n        activeFetchers.set(key, count);\n      }\n    } else {\n      deleteFetcher(key);\n    }\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, \"Expected fetch controller: \" + key);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, \"Expected fetcher: \" + key);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, \"Expected fetcher: \" + key);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers\n    });\n  }\n  function shouldBlockNavigation(_ref2) {\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = _ref2;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n\n    // We ony support a single active blocker at the moment since we don't have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      // If the blocker is currently proceeding, we don't need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n\n    // At this point, we know we're unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({\n      currentLocation,\n      nextLocation,\n      historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function cancelActiveDeferreds(predicate) {\n    let cancelledRouteIds = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: to => init.history.createHref(to),\n    encodeLocation: to => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\n\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction createStaticHandler(routes, opts) {\n  invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n  let manifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties;\n  if (opts != null && opts.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts != null && opts.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  async function query(request, _temp3) {\n    let {\n      requestContext\n    } = _temp3 === void 0 ? {} : _temp3;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, {\n        method\n      });\n      let {\n        matches: methodNotAllowedMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let result = await queryImpl(request, location, matches, requestContext);\n    if (isResponse(result)) {\n      return result;\n    }\n\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return _extends({\n      location,\n      basename\n    }, result);\n  }\n\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */\n  async function queryRoute(request, _temp4) {\n    let {\n      routeId,\n      requestContext\n    } = _temp4 === void 0 ? {} : _temp4;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, {\n        method\n      });\n    } else if (!matches) {\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let result = await queryImpl(request, location, matches, requestContext, match);\n    if (isResponse(result)) {\n      return result;\n    }\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n    if (result.loaderData) {\n      var _result$activeDeferre;\n      let data = Object.values(result.loaderData)[0];\n      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n    return undefined;\n  }\n  async function queryImpl(request, location, matches, requestContext, routeMatch) {\n    invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n        return result;\n      }\n      let result = await loadRouteData(request, matches, requestContext, routeMatch);\n      return isResponse(result) ? result : _extends({}, result, {\n        actionData: null,\n        actionHeaders: {}\n      });\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\n      // it to bail out and then return or throw here based on whether the user\n      // returned or threw\n      if (isQueryRouteResponse(e)) {\n        if (e.type === ResultType.error) {\n          throw e.response;\n        }\n        return e.response;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n    let result;\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    } else {\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, {\n        isStaticRequest: true,\n        isRouteRequest,\n        requestContext\n      });\n      if (request.signal.aborted) {\n        let method = isRouteRequest ? \"queryRoute\" : \"query\";\n        throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n      }\n    }\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.status,\n        headers: {\n          Location: result.location\n        }\n      });\n    }\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    }\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: {\n          [actionMatch.route.id]: result.data\n        },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(request, matches, requestContext, undefined, {\n        [boundaryMatch.route.id]: result.error\n      });\n\n      // action status codes take precedence over loader status codes\n      return _extends({}, context, {\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n        actionData: null,\n        actionHeaders: _extends({}, result.headers ? {\n          [actionMatch.route.id]: result.headers\n        } : {})\n      });\n    }\n\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal\n    });\n    let context = await loadRouteData(loaderRequest, matches, requestContext);\n    return _extends({}, context, result.statusCode ? {\n      statusCode: result.statusCode\n    } : {}, {\n      actionData: {\n        [actionMatch.route.id]: result.data\n      },\n      actionHeaders: _extends({}, result.headers ? {\n        [actionMatch.route.id]: result.headers\n      } : {})\n    });\n  }\n  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n    let isRouteRequest = routeMatch != null;\n\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch == null ? void 0 : routeMatch.route.id\n      });\n    }\n    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);\n\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce((acc, m) => Object.assign(acc, {\n          [m.route.id]: null\n        }), {}),\n        errors: pendingActionError || null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, {\n      isStaticRequest: true,\n      isRouteRequest,\n      requestContext\n    }))]);\n    if (request.signal.aborted) {\n      let method = isRouteRequest ? \"queryRoute\" : \"query\";\n      throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n    }\n\n    // Process and commit output from loaders\n    let activeDeferreds = new Map();\n    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));\n    matches.forEach(match => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n    return _extends({}, context, {\n      matches,\n      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n    });\n  }\n  return {\n    dataRoutes,\n    query,\n    queryRoute\n  };\n}\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nfunction getStaticContextFromError(routes, context, error) {\n  let newContext = _extends({}, context, {\n    statusCode: 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error\n    }\n  });\n  return newContext;\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId) {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n\n  // Resolve the relative path\n  let path = resolveTo(to ? to : \".\", getPathContributingMatches(contextualMatches).map(m => m.pathnameBase), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to=\".\" and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n\n  // Add an ?index param for matched index routes if we don't already have one\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n\n  // If we're operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, {\n      type: \"invalid-body\"\n    })\n  });\n\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== undefined) {\n    if (opts.formEncType === \"text/plain\") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n      Array.from(opts.body.entries()).reduce((acc, _ref3) => {\n        let [name, value] = _ref3;\n        return \"\" + acc + name + \"=\" + value + \"\\n\";\n      }, \"\") : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: undefined,\n    text: undefined\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path,\n      submission\n    };\n  }\n\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = \"?\" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission\n  };\n}\n\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex(m => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    if (match.route.lazy) {\n      // We haven't loaded this route yet so we don't know if it's got a loader!\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n\n    // Always call the loader on new route instances and pending defer cancellations\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {\n      return true;\n    }\n\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult,\n      defaultShouldRevalidate:\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n      isRevalidationRequired ||\n      // Clicked the same link, resubmitted a GET form\n      currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||\n      // Search params affect all loaders\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n    }));\n  });\n\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don't revalidate if fetcher won't be present in the subsequent render\n    if (!matches.some(m => m.route.id === f.routeId) || deletedFetchers.has(key)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew =\n  // [a] -> [a, b]\n  !currentMatch ||\n  // [a, b] -> [a, c]\n  match.route.id !== currentMatch.route.id;\n\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\n\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n\n  // Update the route in place.  This should be safe because there's no way\n  // we could yet be sitting on this route as we can't get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR \"update\" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to \"does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?\".  If not, it should be safe to update in place.\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&\n    // This property isn't static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== \"hasErrorBoundary\";\n    warning(!isPropertyStaticallyDefined, \"Route \\\"\" + routeToUpdate.id + \"\\\" has a static property \\\"\" + lazyRouteProperty + \"\\\" \" + \"defined but its lazy function is also returning a value for this property. \" + (\"The lazy route property \\\"\" + lazyRouteProperty + \"\\\" will be ignored.\"));\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don't resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n    lazy: undefined\n  }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let resultType;\n  let result;\n  let onReject;\n  let runHandler = handler => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    return Promise.race([handler({\n      request,\n      params: match.params,\n      context: opts.requestContext\n    }), abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let handlerError;\n        let values = await Promise.all([\n        // If the handler throws, don't let it immediately bubble out,\n        // since we need to let the lazy() execution finish so we know if this\n        // route has a boundary that can handle the error\n        runHandler(handler).catch(e => {\n          handlerError = e;\n        }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);\n        if (handlerError) {\n          throw handlerError;\n        }\n        result = values[0];\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n        handler = match.route[type];\n        if (handler) {\n          // Handler still run even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don't\n          // hit the invariant below that errors on returning undefined.\n          return {\n            type: ResultType.data,\n            data: undefined\n          };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n    invariant(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + (\"\\\"\" + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  if (isResponse(result)) {\n    let status = result.status;\n\n    // Process redirects\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get(\"Location\");\n      invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n\n      // Support relative routing in internal redirects\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location);\n      } else if (!opts.isStaticRequest) {\n        // Strip off the protocol+origin for same-origin + same-basename absolute\n        // redirects. If this is a static request, we can let it go back to the\n        // browser as-is\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n\n      // Don't process redirects in the router during static requests requests.\n      // Instead, throw the Response and let the server handle it with an HTTP\n      // redirect.  We also update the Location header in place in this flow so\n      // basename and relative routing is taken into account\n      if (opts.isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n        reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n      };\n    }\n\n    // For SSR single-route requests, we want to hand Responses back directly\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n    // interface so we can know whether it was returned or thrown\n    if (opts.isRouteRequest) {\n      let queryRouteResponse = {\n        type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n        response: result\n      };\n      throw queryRouteResponse;\n    }\n    let data;\n    let contentType = result.headers.get(\"Content-Type\");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      data = await result.json();\n    } else {\n      data = await result.text();\n    }\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponseImpl(status, result.statusText, data),\n        headers: result.headers\n      };\n    }\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (resultType === ResultType.error) {\n    return {\n      type: resultType,\n      error: result\n    };\n  }\n  if (isDeferredData(result)) {\n    var _result$init, _result$init2;\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n    };\n  }\n  return {\n    type: ResultType.data,\n    data: result\n  };\n}\n\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = {\n    signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let {\n      formMethod,\n      formEncType\n    } = submission;\n    // Didn't think we needed this but it turns out unlike other methods, patch\n    // won't be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({\n        \"Content-Type\": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n  // Fill in loaderData/errors from our loaders\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n      errors = errors || {};\n\n      // Prefer higher error values if lower errors bubble to the same boundary\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = undefined;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  let {\n    loaderData,\n    errors\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let {\n      key,\n      match,\n      controller\n    } = revalidatingFetchers[index];\n    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n    let result = fetcherResults[index];\n\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, {\n          [boundaryMatch.route.id]: result.error\n        });\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  return {\n    loaderData,\n    errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = _extends({}, newLoaderData);\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn't removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.length === 1 ? routes[0] : routes.find(r => r.index || !r.path || r.path === \"/\") || {\n    id: \"__shim-error-route__\"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: \"\",\n      pathnameBase: \"\",\n      route\n    }],\n    route\n  };\n}\nfunction getInternalRouterError(status, _temp5) {\n  let {\n    pathname,\n    routeId,\n    method,\n    type\n  } = _temp5 === void 0 ? {} : _temp5;\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide a `loader` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = \"Route \\\"\" + routeId + \"\\\" does not match URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = \"No route matches URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method.toUpperCase() + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide an `action` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (method) {\n      errorMessage = \"Invalid request method \\\"\" + method.toUpperCase() + \"\\\"\";\n    }\n  }\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return {\n        result,\n        idx: i\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: \"\"\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    // /page -> /page#hash\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== \"\") {\n    // /page#hash -> /page#other\n    return true;\n  }\n\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n  if (!isResponse(result)) {\n    return false;\n  }\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n  return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n      await resolveDeferredData(result, signal, isFetcher).then(result => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n  if (unwrap === void 0) {\n    unwrap = false;\n  }\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n  }\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data\n  };\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some(v => v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let {\n    formMethod,\n    formAction,\n    formEncType,\n    text,\n    formData,\n    json\n  } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n    if (sessionPositions) {\n      let json = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n    // no-op, use default empty object\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    let json = {};\n    for (let [k, v] of transitions) {\n      json[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n    } catch (error) {\n      warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n    }\n  }\n}\n\n//#endregion\n\nexports.AbortedDeferredError = AbortedDeferredError;\nexports.Action = Action;\nexports.IDLE_BLOCKER = IDLE_BLOCKER;\nexports.IDLE_FETCHER = IDLE_FETCHER;\nexports.IDLE_NAVIGATION = IDLE_NAVIGATION;\nexports.UNSAFE_DEFERRED_SYMBOL = UNSAFE_DEFERRED_SYMBOL;\nexports.UNSAFE_DeferredData = DeferredData;\nexports.UNSAFE_ErrorResponseImpl = ErrorResponseImpl;\nexports.UNSAFE_convertRouteMatchToUiMatch = convertRouteMatchToUiMatch;\nexports.UNSAFE_convertRoutesToDataRoutes = convertRoutesToDataRoutes;\nexports.UNSAFE_getPathContributingMatches = getPathContributingMatches;\nexports.UNSAFE_invariant = invariant;\nexports.UNSAFE_warning = warning;\nexports.createBrowserHistory = createBrowserHistory;\nexports.createHashHistory = createHashHistory;\nexports.createMemoryHistory = createMemoryHistory;\nexports.createPath = createPath;\nexports.createRouter = createRouter;\nexports.createStaticHandler = createStaticHandler;\nexports.defer = defer;\nexports.generatePath = generatePath;\nexports.getStaticContextFromError = getStaticContextFromError;\nexports.getToPathname = getToPathname;\nexports.isDeferredData = isDeferredData;\nexports.isRouteErrorResponse = isRouteErrorResponse;\nexports.joinPaths = joinPaths;\nexports.json = json;\nexports.matchPath = matchPath;\nexports.matchRoutes = matchRoutes;\nexports.normalizePathname = normalizePathname;\nexports.parsePath = parsePath;\nexports.redirect = redirect;\nexports.redirectDocument = redirectDocument;\nexports.resolvePath = resolvePath;\nexports.resolveTo = resolveTo;\nexports.stripBasename = stripBasename;\n//# sourceMappingURL=router.cjs.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","invariant","value","message","Error","warning","cond","console","warn","e","createLocation","current","to","state","location","pathname","search","hash","parsePath","Math","random","toString","substr","createPath","_ref","charAt","path","parsedPath","hashIndex","indexOf","searchIndex","getUrlBasedHistory","getLocation","createHref","validateLocation","options","getIndex","idx","globalHistory","handlePop","action","Action","Pop","nextIndex","delta","index","listener","history","createURL","base","window","origin","href","URL","document","defaultView","v5Compat","replaceState","listen","fn","addEventListener","PopStateEventType","removeEventListener","encodeLocation","url","push","Push","historyState","usr","pushState","error","DOMException","name","replace","Replace","go","n","convertRoutesToDataRoutes","routes","mapRouteProperties","parentPath","manifest","map","route","treePath","id","join","children","indexRoute","pathOrLayoutRoute","undefined","matchRoutes","locationArg","basename","stripBasename","branches","flattenRoutes","rankRouteBranches","matches","decodeURI","routesMeta","branch","matchedParams","matchedPathname","meta","end","remainingPathname","slice","match","matchPath","relativePath","caseSensitive","params","joinPaths","pathnameBase","normalizePathname","convertRouteMatchToUiMatch","loaderData","data","handle","parentsMeta","flattenRoute","childrenIndex","startsWith","concat","score","computeScore","forEach","_route$path","includes","exploded","explodeOptionalSegments","segments","split","first","rest","isOptional","endsWith","required","restExploded","result","subpath","sort","a","b","compareIndexes","initialScore","some","isSplat","splatPenalty","indexRouteValue","filter","s","reduce","segment","paramRe","test","dynamicSegmentValue","emptySegmentValue","staticSegmentValue","every","pattern","matcher","compiledParams","compilePath","captureGroups","memo","paramName","decodeURIComponent","regexpSource","_","RegExp","toLowerCase","startIndex","nextChar","resolvePath","fromPathname","toPathname","resolvePathname","relativeSegments","pop","getInvalidPathError","char","field","dest","JSON","stringify","getPathContributingMatches","resolveTo","toArg","routePathnames","locationPathname","isPathRelative","isEmptyPath","from","fromSegments","toSegments","shift","routePathnameIndex","hasExplicitTrailingSlash","hasCurrentTrailingSlash","isRouteErrorResponse","status","statusText","internal","normalizeTo","prependBasename","fromRouteId","relative","contextualMatches","activeRouteMatch","m","hasNakedIndexQuery","normalizeNavigateOptions","normalizeFormMethod","isFetcher","opts","formData","body","formMethod","validRequestMethods","has","getInternalRouterError","method","getInvalidBodyError","type","rawFormMethod","toUpperCase","formAction","stripHashFromPath","formEncType","isMutationMethod","text","FormData","URLSearchParams","Array","entries","acc","_ref3","String","submission","json","parse","searchParams","convertFormDataToSearchParams","convertSearchParamsToFormData","append","getLoaderMatchesUntilBoundary","boundaryId","boundaryMatches","findIndex","getMatchesToLoad","isRevalidationRequired","cancelledDeferredRoutes","cancelledFetcherLoads","deletedFetchers","fetchLoadMatches","fetchRedirectIds","routesToUse","pendingActionData","pendingError","actionResult","values","currentUrl","nextUrl","keys","navigationMatches","lazy","loader","isNewLoader","currentRouteMatch","shouldRevalidateLoader","currentParams","nextParams","defaultShouldRevalidate","isNewRouteInstance","revalidatingFetchers","f","routeId","fetcherMatches","fetcher","fetchers","get","fetcherMatch","getTargetMatch","shouldRevalidate","controller","AbortController","currentLoaderData","currentMatch","isMissingData","currentPath","loaderMatch","arg","routeChoice","loadLazyRouteModule","lazyRoute","routeToUpdate","routeUpdates","lazyRouteProperty","isPropertyStaticallyDefined","staticRouteValue","immutableRouteKeys","callLoaderOrAction","request","onReject","runHandler","handler","reject","abortPromise","Promise","r","signal","race","context","requestContext","handlerError","all","catch","ResultType","resultType","isResponse","redirectStatusCodes","headers","ABSOLUTE_URL_REGEX","isStaticRequest","protocol","isSameBasename","set","redirect","revalidate","reloadDocument","isRouteRequest","queryRouteResponse","response","contentType","ErrorResponseImpl","statusCode","isDeferredData","_result$init","_result$init2","deferred","deferredData","init","Headers","createClientSideRequest","Request","processRouteLoaderData","matchesToLoad","results","activeDeferreds","errors","foundError","loaderHeaders","isRedirectResult","isErrorResult","boundaryMatch","findNearestBoundary","isDeferredResult","processLoaderData","fetcherResults","aborted","delete","doneFetcher","getDoneFetcher","mergeLoaderData","newLoaderData","mergedLoaderData","reverse","eligibleMatches","find","hasErrorBoundary","getShortCircuitMatches","_temp5","errorMessage","findRedirect","subscribe","cancel","resolveData","validMutationMethods","resolveDeferredResults","currentMatches","signals","isRevalidatingLoader","resolveDeferredData","then","unwrap","unwrappedData","getAll","v","pathMatches","getSubmissionFromNavigation","navigation","getLoadingNavigation","getLoadingFetcher","restoreAppliedTransitions","_window","transitions","sessionPositions","sessionStorage","getItem","TRANSITIONS_STORAGE_KEY","k","isArray","Set","defineProperty","paths","AbortedDeferredError","DeferredData","constructor","responseInit","pendingKeysSet","subscribers","deferredKeys","onAbort","unlistenAbortSignal","this.unlistenAbortSignal","_ref2","trackPromise","done","add","promise","onSettle","undefinedError","emit","settledKey","subscriber","abort","resolve","size","_tracked","_error","_data","Response","validMutationMethodsArr","validRequestMethodsArr","redirectPreserveMethodStatusCodes","IDLE_NAVIGATION","IDLE_FETCHER","IDLE_BLOCKER","proceed","reset","defaultMapRouteProperties","UNSAFE_DEFERRED_SYMBOL","Symbol","UNSAFE_DeferredData","UNSAFE_ErrorResponseImpl","UNSAFE_convertRouteMatchToUiMatch","UNSAFE_convertRoutesToDataRoutes","UNSAFE_getPathContributingMatches","UNSAFE_invariant","UNSAFE_warning","createBrowserHistory","createBrowserLocation","createBrowserHref","createHashHistory","createHashLocation","createHashHref","querySelector","getAttribute","validateHashLocation","createMemoryHistory","createMemoryLocation","initialEntries","initialIndex","entry","min","max","nextLocation","splice","createRouter","updateState","newState","completedFetchers","deletedFetchersKeys","future","v7_fetcherPersist","unstable_viewTransitionOpts","viewTransitionOpts","unstable_flushSync","flushSync","deleteFetcher","completeNavigation","_temp","_location$state","_location$state2","isActionReload","actionData","_isRedirect","blockers","Map","preventScrollReset","pendingPreventScrollReset","inFlightDataRoutes","dataRoutes","isUninterruptedRevalidation","pendingAction","priorPaths","appliedViewTransitions","currentLocation","pendingViewTransitionEnabled","toPaths","historyAction","initialized","revalidation","restoreScrollPosition","getSavedScrollPosition","navigate","normalizedPath","v7_prependBasename","v7_normalizeFormMethod","userReplace","blockerKey","shouldBlockNavigation","updateBlocker","startNavigation","enableViewTransition","unstable_viewTransition","pendingNavigationController","startUninterruptedRevalidation","savedScrollPositions","getScrollPosition","getScrollKey","loadingNavigation","overrideNavigation","actionOutput","handleAction","shortCircuited","pendingActionError","handleLoaders","fetcherSubmission","notFoundMatches","cancelActiveDeferreds","interruptActiveLoads","actionMatch","startRedirectNavigation","activeSubmission","pendingNavigationLoadId","incrementingLoadId","updatedFetchers","markFetchRedirectsDone","rf","revalidatingFetcher","fetchControllers","abortFetcher","abortPendingFetchRevalidations","loaderResults","callLoadersAndMaybeResolveData","didAbortFetchLoads","abortStaleFetchLoads","handleFetcherAction","requestMatches","existingFetcher","updateFetcherState","abortController","fetchRequest","originatingLoadId","setFetcherError","revalidationRequest","loadId","fetchReloadIds","loadFetcher","staleKey","handleFetcherLoader","_temp2","redirectLocation","isBrowser","isDocumentReload","routerWindow","redirectHistoryAction","fetchersToLoad","getFetcher","activeFetchers","markFetchersDone","doneKeys","landedId","yeetedKeys","deleteBlocker","blockerFunctions","newBlocker","blocker","blockerFunction","predicate","cancelledRouteIds","dfd","getScrollRestorationKey","y","createElement","isServer","detectErrorBoundary","unlistenHistory","initialScrollRestored","hydrationData","initialMatches","initialErrors","router","removePageHideEventListener","ignoreNextHistoryUpdate","initialize","_saveAppliedTransitions","setItem","enableScrollRestoration","positions","getPosition","getKey","fetch","deleteFetcherAndUpdateState","count","dispose","clear","getBlocker","_internalFetchControllers","_internalActiveDeferreds","_internalSetRoutes","newRoutes","createStaticHandler","queryImpl","routeMatch","submit","loadRouteData","actionHeaders","obj","Location","loaderRequest","executedLoaders","fromEntries","query","_temp3","methodNotAllowedMatches","queryRoute","_temp4","_result$activeDeferre","defer","generatePath","originalPath","prefix","p","array","star","keyMatch","optional","param","getStaticContextFromError","newContext","_deepestRenderedBoundaryId","getToPathname","redirectDocument"]
}
