shadow$provide.module$node_modules$$remix_run$router$dist$router_cjs=function(global,require,module,exports){function _extends(){_extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i],key;for(key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};return _extends.apply(this,arguments)}function invariant(value,message){if(!1===value||null===value||"undefined"===typeof value)throw Error(message);
}function warning(cond,message){if(!cond){"undefined"!==typeof console&&console.warn(message);try{throw Error(message);}catch(e){}}}function createLocation(current,to,state,key){void 0===state&&(state=null);return _extends({pathname:"string"===typeof current?current:current.pathname,search:"",hash:""},"string"===typeof to?parsePath(to):to,{state,key:to&&to.key||key||Math.random().toString(36).substr(2,8)})}function createPath(_ref){let {pathname="/",search="",hash=""}=_ref;search&&"?"!==search&&(pathname+=
"?"===search.charAt(0)?search:"?"+search);hash&&"#"!==hash&&(pathname+="#"===hash.charAt(0)?hash:"#"+hash);return pathname}function parsePath(path){let parsedPath={};if(path){var hashIndex=path.indexOf("#");0<=hashIndex&&(parsedPath.hash=path.substr(hashIndex),path=path.substr(0,hashIndex));hashIndex=path.indexOf("?");0<=hashIndex&&(parsedPath.search=path.substr(hashIndex),path=path.substr(0,hashIndex));path&&(parsedPath.pathname=path)}return parsedPath}function getUrlBasedHistory(getLocation,createHref,
validateLocation,options){function getIndex(){return(globalHistory.state||{idx:null}).idx}function handlePop(){action=Action.Pop;let nextIndex=getIndex(),delta=null==nextIndex?null:nextIndex-index;index=nextIndex;listener&&listener({action,location:history.location,delta})}function createURL(to){let base="null"!==window.location.origin?window.location.origin:window.location.href;to="string"===typeof to?to:createPath(to);invariant(base,"No window.location.(origin|href) available to create URL for href: "+
to);return new URL(to,base)}void 0===options&&(options={});let {window=document.defaultView,v5Compat=!1}=options,globalHistory=window.history,action=Action.Pop,listener=null,index=getIndex();null==index&&(index=0,globalHistory.replaceState(_extends({},globalHistory.state,{idx:index}),""));let history={get action(){return action},get location(){return getLocation(window,globalHistory)},listen(fn){if(listener)throw Error("A history only accepts one active listener");window.addEventListener("popstate",
handlePop);listener=fn;return()=>{window.removeEventListener("popstate",handlePop);listener=null}},createHref(to){return createHref(window,to)},createURL,encodeLocation(to){to=createURL(to);return{pathname:to.pathname,search:to.search,hash:to.hash}},push:function(to,state){action=Action.Push;state=createLocation(history.location,to,state);validateLocation&&validateLocation(state,to);index=getIndex()+1;to={usr:state.state,key:state.key,idx:index};state=history.createHref(state);try{globalHistory.pushState(to,
"",state)}catch(error){if(error instanceof DOMException&&"DataCloneError"===error.name)throw error;window.location.assign(state)}v5Compat&&listener&&listener({action,location:history.location,delta:1})},replace:function(to,state){action=Action.Replace;state=createLocation(history.location,to,state);validateLocation&&validateLocation(state,to);index=getIndex();to={usr:state.state,key:state.key,idx:index};state=history.createHref(state);globalHistory.replaceState(to,"",state);v5Compat&&listener&&listener({action,
location:history.location,delta:0})},go(n){return globalHistory.go(n)}};return history}function convertRoutesToDataRoutes(routes,mapRouteProperties,parentPath,manifest){void 0===parentPath&&(parentPath=[]);void 0===manifest&&(manifest={});return routes.map((route,index)=>{let treePath=[...parentPath,index];index="string"===typeof route.id?route.id:treePath.join("-");invariant(!0!==route.index||!route.children,"Cannot specify children on an index route");invariant(!manifest[index],'Found a route id collision on id "'+
index+"\".  Route id's must be globally unique within Data Router usages");if(!0===route.index)return route=_extends({},route,mapRouteProperties(route),{id:index}),manifest[index]=route;let pathOrLayoutRoute=_extends({},route,mapRouteProperties(route),{id:index,children:void 0});manifest[index]=pathOrLayoutRoute;route.children&&(pathOrLayoutRoute.children=convertRoutesToDataRoutes(route.children,mapRouteProperties,treePath,manifest));return pathOrLayoutRoute})}function matchRoutes(routes,locationArg,
basename){void 0===basename&&(basename="/");locationArg="string"===typeof locationArg?parsePath(locationArg):locationArg;basename=stripBasename(locationArg.pathname||"/",basename);if(null==basename)return null;routes=flattenRoutes(routes);rankRouteBranches(routes);var matches=null;for(locationArg=0;null==matches&&locationArg<routes.length;++locationArg){var JSCompiler_temp_const=routes[locationArg];matches=basename;try{var JSCompiler_inline_result=decodeURI(matches)}catch(error){warning(!1,'The URL path "'+
matches+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+(error+").")),JSCompiler_inline_result=matches}a:{matches=JSCompiler_inline_result;({routesMeta:JSCompiler_temp_const}=JSCompiler_temp_const);let matchedParams={},matchedPathname="/",matches$jscomp$0=[];for(let i=0;i<JSCompiler_temp_const.length;++i){var meta=JSCompiler_temp_const[i],end=i===JSCompiler_temp_const.length-1;let remainingPathname="/"===matchedPathname?matches:matches.slice(matchedPathname.length)||
"/";end=matchPath({path:meta.relativePath,caseSensitive:meta.caseSensitive,end},remainingPathname);if(!end){matches=null;break a}Object.assign(matchedParams,end.params);meta=meta.route;matches$jscomp$0.push({params:matchedParams,pathname:joinPaths([matchedPathname,end.pathname]),pathnameBase:normalizePathname(joinPaths([matchedPathname,end.pathnameBase])),route:meta});"/"!==end.pathnameBase&&(matchedPathname=joinPaths([matchedPathname,end.pathnameBase]))}matches=matches$jscomp$0}}return matches}function convertRouteMatchToUiMatch(match,
loaderData){let {route,pathname,params}=match;return{id:route.id,pathname,params,data:loaderData[route.id],handle:route.handle}}function flattenRoutes(routes,branches,parentsMeta,parentPath){void 0===branches&&(branches=[]);void 0===parentsMeta&&(parentsMeta=[]);void 0===parentPath&&(parentPath="");let flattenRoute=(route,index,relativePath)=>{relativePath={relativePath:void 0===relativePath?route.path||"":relativePath,caseSensitive:!0===route.caseSensitive,childrenIndex:index,route};relativePath.relativePath.startsWith("/")&&
(invariant(relativePath.relativePath.startsWith(parentPath),'Absolute route path "'+relativePath.relativePath+'" nested under path "'+(parentPath+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.')),relativePath.relativePath=relativePath.relativePath.slice(parentPath.length));index=joinPaths([parentPath,relativePath.relativePath]);relativePath=parentsMeta.concat(relativePath);route.children&&0<route.children.length&&(invariant(!0!==route.index,
'Index routes must not have child routes. Please remove all child routes from route path "'+(index+'".')),flattenRoutes(route.children,branches,relativePath,index));(null!=route.path||route.index)&&branches.push({path:index,score:computeScore(index,route.index),routesMeta:relativePath})};routes.forEach((route,index)=>{var _route$path;if(""!==route.path&&null!=(_route$path=route.path)&&_route$path.includes("?"))for(let exploded of explodeOptionalSegments(route.path))flattenRoute(route,index,exploded);
else flattenRoute(route,index)});return branches}function explodeOptionalSegments(path){var segments=path.split("/");if(0===segments.length)return[];let [first,...rest]=segments;segments=first.endsWith("?");let required=first.replace(/\?$/,"");if(0===rest.length)return segments?[required,""]:[required];let restExploded=explodeOptionalSegments(rest.join("/")),result=[];result.push(...restExploded.map(subpath=>""===subpath?required:[required,subpath].join("/")));segments&&result.push(...restExploded);
return result.map(exploded=>path.startsWith("/")&&""===exploded?"/":exploded)}function rankRouteBranches(branches){branches.sort((a,b)=>a.score!==b.score?b.score-a.score:compareIndexes(a.routesMeta.map(meta=>meta.childrenIndex),b.routesMeta.map(meta=>meta.childrenIndex)))}function computeScore(path,index){path=path.split("/");let initialScore=path.length;path.some(isSplat)&&(initialScore+=-2);index&&(initialScore+=2);return path.filter(s=>"*"!==s).reduce((score,segment)=>score+(paramRe.test(segment)?
3:""===segment?1:10),initialScore)}function compareIndexes(a,b){return a.length===b.length&&a.slice(0,-1).every((n,i)=>n===b[i])?a[a.length-1]-b[b.length-1]:0}function matchPath(pattern,pathname){"string"===typeof pattern&&(pattern={path:pattern,caseSensitive:!1,end:!0});let [matcher,compiledParams]=compilePath(pattern.path,pattern.caseSensitive,pattern.end);pathname=pathname.match(matcher);if(!pathname)return null;let matchedPathname=pathname[0],pathnameBase=matchedPathname.replace(/(.)\/+$/,"$1"),
captureGroups=pathname.slice(1);return{params:compiledParams.reduce((memo,_ref,index)=>{let {paramName,isOptional}=_ref;"*"===paramName&&(pathnameBase=matchedPathname.slice(0,matchedPathname.length-(captureGroups[index]||"").length).replace(/(.)\/+$/,"$1"));_ref=captureGroups[index];if(isOptional&&!_ref)memo[paramName]=void 0;else{_ref=_ref||"";try{var JSCompiler_inline_result=decodeURIComponent(_ref)}catch(error){warning(!1,'The value for the URL param "'+paramName+'" will not be decoded because the string "'+
(_ref+'" is a malformed URL segment. This is probably due to a bad percent encoding (')+(error+").")),JSCompiler_inline_result=_ref}memo[paramName]=JSCompiler_inline_result}return memo},{}),pathname:matchedPathname,pathnameBase,pattern}}function compilePath(path,caseSensitive,end){void 0===caseSensitive&&(caseSensitive=!1);void 0===end&&(end=!0);warning("*"===path||!path.endsWith("*")||path.endsWith("/*"),'Route path "'+path+'" will be treated as if it were "'+(path.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "')+
(path.replace(/\*$/,"/*")+'".'));let params=[],regexpSource="^"+path.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$\x26").replace(/\/:(\w+)(\?)?/g,(_,paramName,isOptional)=>{params.push({paramName,isOptional:null!=isOptional});return isOptional?"/?([^\\/]+)?":"/([^\\/]+)"});path.endsWith("*")?(params.push({paramName:"*"}),regexpSource+="*"===path||"/*"===path?"(.*)$":"(?:\\/(.+)|\\/*)$"):end?regexpSource+="\\/*$":""!==path&&"/"!==path&&(regexpSource+="(?:(?\x3d\\/|$))");
return[new RegExp(regexpSource,caseSensitive?void 0:"i"),params]}function stripBasename(pathname,basename){if("/"===basename)return pathname;if(!pathname.toLowerCase().startsWith(basename.toLowerCase()))return null;basename=basename.endsWith("/")?basename.length-1:basename.length;let nextChar=pathname.charAt(basename);return nextChar&&"/"!==nextChar?null:pathname.slice(basename)||"/"}function resolvePath(to,fromPathname){void 0===fromPathname&&(fromPathname="/");let {pathname:toPathname,search="",
hash=""}="string"===typeof to?parsePath(to):to;to=toPathname?toPathname.startsWith("/")?toPathname:resolvePathname(toPathname,fromPathname):fromPathname;fromPathname=search&&"?"!==search?search.startsWith("?")?search:"?"+search:"";var JSCompiler_inline_result=hash&&"#"!==hash?hash.startsWith("#")?hash:"#"+hash:"";return{pathname:to,search:fromPathname,hash:JSCompiler_inline_result}}function resolvePathname(relativePath,fromPathname){let segments=fromPathname.replace(/\/+$/,"").split("/");relativePath.split("/").forEach(segment=>
{".."===segment?1<segments.length&&segments.pop():"."!==segment&&segments.push(segment)});return 1<segments.length?segments.join("/"):"/"}function getInvalidPathError(char,field,dest,path){return"Cannot include a '"+char+"' character in a manually specified `to."+(field+"` field ["+JSON.stringify(path)+"].  Please separate it out to the `to.")+(dest+'` field. Alternatively you may provide the full path as a string in \x3cLink to\x3d"..."\x3e and the router will parse it for you.')}function getPathContributingMatches(matches){return matches.filter((match,
index)=>0===index||match.route.path&&0<match.route.path.length)}function resolveTo(toArg,routePathnames,locationPathname,isPathRelative){void 0===isPathRelative&&(isPathRelative=!1);if("string"===typeof toArg)var to=parsePath(toArg);else to=_extends({},toArg),invariant(!to.pathname||!to.pathname.includes("?"),getInvalidPathError("?","pathname","search",to)),invariant(!to.pathname||!to.pathname.includes("#"),getInvalidPathError("#","pathname","hash",to)),invariant(!to.search||!to.search.includes("#"),
getInvalidPathError("#","search","hash",to));let toPathname=(toArg=""===toArg||""===to.pathname)?"/":to.pathname;if(null==toPathname)routePathnames=locationPathname;else if(isPathRelative){routePathnames=routePathnames[routePathnames.length-1].replace(/^\//,"").split("/");if(toPathname.startsWith("..")){for(isPathRelative=toPathname.split("/");".."===isPathRelative[0];)isPathRelative.shift(),routePathnames.pop();to.pathname=isPathRelative.join("/")}routePathnames="/"+routePathnames.join("/")}else{isPathRelative=
routePathnames.length-1;if(toPathname.startsWith("..")){let toSegments=toPathname.split("/");for(;".."===toSegments[0];)toSegments.shift(),--isPathRelative;to.pathname=toSegments.join("/")}routePathnames=0<=isPathRelative?routePathnames[isPathRelative]:"/"}to=resolvePath(to,routePathnames);routePathnames=toPathname&&"/"!==toPathname&&toPathname.endsWith("/");locationPathname=(toArg||"."===toPathname)&&locationPathname.endsWith("/");to.pathname.endsWith("/")||!routePathnames&&!locationPathname||(to.pathname+=
"/");return to}function isRouteErrorResponse(error){return null!=error&&"number"===typeof error.status&&"string"===typeof error.statusText&&"boolean"===typeof error.internal&&"data"in error}function normalizeTo(location,matches,basename,prependBasename,to,fromRouteId,relative){let contextualMatches,activeRouteMatch;if(fromRouteId){contextualMatches=[];for(let match of matches)if(contextualMatches.push(match),match.route.id===fromRouteId){activeRouteMatch=match;break}}else contextualMatches=matches,
activeRouteMatch=matches[matches.length-1];matches=resolveTo(to?to:".",getPathContributingMatches(contextualMatches).map(m=>m.pathnameBase),stripBasename(location.pathname,basename)||location.pathname,"path"===relative);null==to&&(matches.search=location.search,matches.hash=location.hash);null!=to&&""!==to&&"."!==to||!activeRouteMatch||!activeRouteMatch.route.index||hasNakedIndexQuery(matches.search)||(matches.search=matches.search?matches.search.replace(/^\?/,"?index\x26"):"?index");prependBasename&&
"/"!==basename&&(matches.pathname="/"===matches.pathname?basename:joinPaths([basename,matches.pathname]));return createPath(matches)}function normalizeNavigateOptions(normalizeFormMethod,isFetcher,path,opts){if(!opts||null==opts||!("formData"in opts&&null!=opts.formData||"body"in opts&&void 0!==opts.body))return{path};if(opts.formMethod&&!validRequestMethods.has(opts.formMethod.toLowerCase()))return{path,error:getInternalRouterError(405,{method:opts.formMethod})};var getInvalidBodyError=()=>({path,
error:getInternalRouterError(400,{type:"invalid-body"})}),rawFormMethod=opts.formMethod||"get";normalizeFormMethod=normalizeFormMethod?rawFormMethod.toUpperCase():rawFormMethod.toLowerCase();rawFormMethod=stripHashFromPath(path);if(void 0!==opts.body){if("text/plain"===opts.formEncType){if(!isMutationMethod(normalizeFormMethod))return getInvalidBodyError();isFetcher="string"===typeof opts.body?opts.body:opts.body instanceof FormData||opts.body instanceof URLSearchParams?Array.from(opts.body.entries()).reduce((acc,
_ref3)=>{let [name,value]=_ref3;return""+acc+name+"\x3d"+value+"\n"},""):String(opts.body);return{path,submission:{formMethod:normalizeFormMethod,formAction:rawFormMethod,formEncType:opts.formEncType,formData:void 0,json:void 0,text:isFetcher}}}if("application/json"===opts.formEncType){if(!isMutationMethod(normalizeFormMethod))return getInvalidBodyError();try{let json="string"===typeof opts.body?JSON.parse(opts.body):opts.body;return{path,submission:{formMethod:normalizeFormMethod,formAction:rawFormMethod,
formEncType:opts.formEncType,formData:void 0,json,text:void 0}}}catch(e){return getInvalidBodyError()}}}invariant("function"===typeof FormData,"FormData is not available in this environment");let searchParams,formData;if(opts.formData)searchParams=convertFormDataToSearchParams(opts.formData),formData=opts.formData;else if(opts.body instanceof FormData)searchParams=convertFormDataToSearchParams(opts.body),formData=opts.body;else if(opts.body instanceof URLSearchParams)searchParams=opts.body,formData=
convertSearchParamsToFormData(searchParams);else if(null==opts.body)searchParams=new URLSearchParams,formData=new FormData;else try{searchParams=new URLSearchParams(opts.body),formData=convertSearchParamsToFormData(searchParams)}catch(e){return getInvalidBodyError()}opts={formMethod:normalizeFormMethod,formAction:rawFormMethod,formEncType:opts&&opts.formEncType||"application/x-www-form-urlencoded",formData,json:void 0,text:void 0};if(isMutationMethod(opts.formMethod))return{path,submission:opts};
getInvalidBodyError=parsePath(path);isFetcher&&getInvalidBodyError.search&&hasNakedIndexQuery(getInvalidBodyError.search)&&searchParams.append("index","");getInvalidBodyError.search="?"+searchParams;return{path:createPath(getInvalidBodyError),submission:opts}}function getLoaderMatchesUntilBoundary(matches,boundaryId){let boundaryMatches=matches;if(boundaryId){let index=matches.findIndex(m=>m.route.id===boundaryId);0<=index&&(boundaryMatches=matches.slice(0,index))}return boundaryMatches}function getMatchesToLoad(history,
state,matches,submission,location,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,deletedFetchers,fetchLoadMatches,fetchRedirectIds,routesToUse,basename,pendingActionData,pendingError){let actionResult=pendingError?Object.values(pendingError)[0]:pendingActionData?Object.values(pendingActionData)[0]:void 0,currentUrl=history.createURL(state.location),nextUrl=history.createURL(location);history=pendingError?Object.keys(pendingError)[0]:void 0;history=getLoaderMatchesUntilBoundary(matches,
history).filter((match,index)=>{if(match.route.lazy)return!0;if(null==match.route.loader)return!1;if(isNewLoader(state.loaderData,state.matches[index],match)||cancelledDeferredRoutes.some(id=>id===match.route.id))return!0;index=state.matches[index];return shouldRevalidateLoader(match,_extends({currentUrl,currentParams:index.params,nextUrl,nextParams:match.params},submission,{actionResult,defaultShouldRevalidate:isRevalidationRequired||currentUrl.pathname+currentUrl.search===nextUrl.pathname+nextUrl.search||
currentUrl.search!==nextUrl.search||isNewRouteInstance(index,match)}))});let revalidatingFetchers=[];fetchLoadMatches.forEach((f,key)=>{if(matches.some(m=>m.route.id===f.routeId)&&!deletedFetchers.has(key)){var fetcherMatches=matchRoutes(routesToUse,f.path,basename);if(fetcherMatches){var fetcher=state.fetchers.get(key),fetcherMatch=getTargetMatch(fetcherMatches,f.path),shouldRevalidate=!1;(shouldRevalidate=fetchRedirectIds.has(key)?!1:cancelledFetcherLoads.includes(key)?!0:fetcher&&"idle"!==fetcher.state&&
void 0===fetcher.data?isRevalidationRequired:shouldRevalidateLoader(fetcherMatch,_extends({currentUrl,currentParams:state.matches[state.matches.length-1].params,nextUrl,nextParams:matches[matches.length-1].params},submission,{actionResult,defaultShouldRevalidate:isRevalidationRequired})))&&revalidatingFetchers.push({key,routeId:f.routeId,path:f.path,matches:fetcherMatches,match:fetcherMatch,controller:new AbortController})}else revalidatingFetchers.push({key,routeId:f.routeId,path:f.path,matches:null,
match:null,controller:null})}});return[history,revalidatingFetchers]}function isNewLoader(currentLoaderData,currentMatch,match){currentLoaderData=void 0===currentLoaderData[match.route.id];return!currentMatch||match.route.id!==currentMatch.route.id||currentLoaderData}function isNewRouteInstance(currentMatch,match){let currentPath=currentMatch.route.path;return currentMatch.pathname!==match.pathname||null!=currentPath&&currentPath.endsWith("*")&&currentMatch.params["*"]!==match.params["*"]}function shouldRevalidateLoader(loaderMatch,
arg){return loaderMatch.route.shouldRevalidate&&(loaderMatch=loaderMatch.route.shouldRevalidate(arg),"boolean"===typeof loaderMatch)?loaderMatch:arg.defaultShouldRevalidate}async function loadLazyRouteModule(route,mapRouteProperties,manifest){if(route.lazy){var lazyRoute=await route.lazy();if(route.lazy){route=manifest[route.id];invariant(route,"No route found in manifest");manifest={};for(let lazyRouteProperty in lazyRoute){let isPropertyStaticallyDefined=void 0!==route[lazyRouteProperty]&&"hasErrorBoundary"!==
lazyRouteProperty;warning(!isPropertyStaticallyDefined,'Route "'+route.id+'" has a static property "'+lazyRouteProperty+'" defined but its lazy function is also returning a value for this property. The lazy route property "'+(lazyRouteProperty+'" will be ignored.'));isPropertyStaticallyDefined||immutableRouteKeys.has(lazyRouteProperty)||(manifest[lazyRouteProperty]=lazyRoute[lazyRouteProperty])}Object.assign(route,manifest);Object.assign(route,_extends({},mapRouteProperties(route),{lazy:void 0}))}}}
async function callLoaderOrAction(type,request,match,matches,manifest,mapRouteProperties,basename,opts){void 0===opts&&(opts={});let result,onReject,runHandler=handler=>{let reject,abortPromise=new Promise((_,r)=>reject=r);onReject=()=>reject();request.signal.addEventListener("abort",onReject);return Promise.race([handler({request,params:match.params,context:opts.requestContext}),abortPromise])};try{let handler=match.route[type];if(match.route.lazy)if(handler){let handlerError,values=await Promise.all([runHandler(handler).catch(e=>
{handlerError=e}),loadLazyRouteModule(match.route,mapRouteProperties,manifest)]);if(handlerError)throw handlerError;result=values[0]}else if(await loadLazyRouteModule(match.route,mapRouteProperties,manifest),handler=match.route[type])result=await runHandler(handler);else{if("action"===type){let url=new URL(request.url);throw getInternalRouterError(405,{method:request.method,pathname:url.pathname+url.search,routeId:match.route.id});}return{type:ResultType.data,data:void 0}}else if(handler)result=await runHandler(handler);
else{let url=new URL(request.url);throw getInternalRouterError(404,{pathname:url.pathname+url.search});}invariant(void 0!==result,"You defined "+("action"===type?"an action":"a loader")+' for route "'+(match.route.id+"\" but didn't return anything from your `"+type+"` function. Please return a value or `null`."))}catch(e){var resultType=ResultType.error;result=e}finally{onReject&&request.signal.removeEventListener("abort",onReject)}if(isResponse(result)){type=result.status;if(redirectStatusCodes.has(type)){resultType=
result.headers.get("Location");invariant(resultType,"Redirects returned/thrown from loaders/actions must have a Location header");ABSOLUTE_URL_REGEX.test(resultType)?opts.isStaticRequest||(matches=new URL(request.url),manifest=resultType.startsWith("//")?new URL(matches.protocol+resultType):new URL(resultType),basename=null!=stripBasename(manifest.pathname,basename),manifest.origin===matches.origin&&basename&&(resultType=manifest.pathname+manifest.search+manifest.hash)):resultType=normalizeTo(new URL(request.url),
matches.slice(0,matches.indexOf(match)+1),basename,!0,resultType);if(opts.isStaticRequest)throw result.headers.set("Location",resultType),result;return{type:ResultType.redirect,status:type,location:resultType,revalidate:null!==result.headers.get("X-Remix-Revalidate"),reloadDocument:null!==result.headers.get("X-Remix-Reload-Document")}}if(opts.isRouteRequest)throw{type:resultType===ResultType.error?ResultType.error:ResultType.data,response:result};basename=(basename=result.headers.get("Content-Type"))&&
/\bapplication\/json\b/.test(basename)?await result.json():await result.text();return resultType===ResultType.error?{type:resultType,error:new ErrorResponseImpl(type,result.statusText,basename),headers:result.headers}:{type:ResultType.data,data:basename,statusCode:result.status,headers:result.headers}}if(resultType===ResultType.error)return{type:resultType,error:result};if(isDeferredData(result)){var _result$init,_result$init2;return{type:ResultType.deferred,deferredData:result,statusCode:null==(_result$init=
result.init)?void 0:_result$init.status,headers:(null==(_result$init2=result.init)?void 0:_result$init2.headers)&&new Headers(result.init.headers)}}return{type:ResultType.data,data:result}}function createClientSideRequest(history,location,signal,submission){history=history.createURL(stripHashFromPath(location)).toString();signal={signal};if(submission&&isMutationMethod(submission.formMethod)){let {formMethod,formEncType}=submission;signal.method=formMethod.toUpperCase();"application/json"===formEncType?
(signal.headers=new Headers({"Content-Type":formEncType}),signal.body=JSON.stringify(submission.json)):signal.body="text/plain"===formEncType?submission.text:"application/x-www-form-urlencoded"===formEncType&&submission.formData?convertFormDataToSearchParams(submission.formData):submission.formData}return new Request(history,signal)}function convertFormDataToSearchParams(formData){let searchParams=new URLSearchParams;for(let [key,value]of formData.entries())searchParams.append(key,"string"===typeof value?
value:value.name);return searchParams}function convertSearchParamsToFormData(searchParams){let formData=new FormData;for(let [key,value]of searchParams.entries())formData.append(key,value);return formData}function processRouteLoaderData(matches,matchesToLoad,results,pendingError,activeDeferreds){let loaderData={},errors=null,statusCode,foundError=!1,loaderHeaders={};results.forEach((result,index)=>{index=matchesToLoad[index].route.id;invariant(!isRedirectResult(result),"Cannot handle redirect results in processLoaderData");
if(isErrorResult(result)){let boundaryMatch=findNearestBoundary(matches,index),error=result.error;pendingError&&(error=Object.values(pendingError)[0],pendingError=void 0);errors=errors||{};null==errors[boundaryMatch.route.id]&&(errors[boundaryMatch.route.id]=error);loaderData[index]=void 0;foundError||(foundError=!0,statusCode=isRouteErrorResponse(result.error)?result.error.status:500)}else isDeferredResult(result)?(activeDeferreds.set(index,result.deferredData),loaderData[index]=result.deferredData.data):
loaderData[index]=result.data,null==result.statusCode||200===result.statusCode||foundError||(statusCode=result.statusCode);result.headers&&(loaderHeaders[index]=result.headers)});pendingError&&(errors=pendingError,loaderData[Object.keys(pendingError)[0]]=void 0);return{loaderData,errors,statusCode:statusCode||200,loaderHeaders}}function processLoaderData(state,matches,matchesToLoad,results,pendingError,revalidatingFetchers,fetcherResults,activeDeferreds){let {loaderData,errors}=processRouteLoaderData(matches,
matchesToLoad,results,pendingError,activeDeferreds);for(matches=0;matches<revalidatingFetchers.length;matches++){let {key,match,controller}=revalidatingFetchers[matches];invariant(void 0!==fetcherResults&&void 0!==fetcherResults[matches],"Did not find corresponding fetcher result");matchesToLoad=fetcherResults[matches];controller&&controller.signal.aborted||(isErrorResult(matchesToLoad)?(results=findNearestBoundary(state.matches,null==match?void 0:match.route.id),errors&&errors[results.route.id]||
(errors=_extends({},errors,{[results.route.id]:matchesToLoad.error})),state.fetchers.delete(key)):isRedirectResult(matchesToLoad)?invariant(!1,"Unhandled fetcher revalidation redirect"):isDeferredResult(matchesToLoad)?invariant(!1,"Unhandled fetcher deferred data"):(matchesToLoad=getDoneFetcher(matchesToLoad.data),state.fetchers.set(key,matchesToLoad)))}return{loaderData,errors}}function mergeLoaderData(loaderData,newLoaderData,matches,errors){let mergedLoaderData=_extends({},newLoaderData);for(let match of matches)if(matches=
match.route.id,newLoaderData.hasOwnProperty(matches)?void 0!==newLoaderData[matches]&&(mergedLoaderData[matches]=newLoaderData[matches]):void 0!==loaderData[matches]&&match.route.loader&&(mergedLoaderData[matches]=loaderData[matches]),errors&&errors.hasOwnProperty(matches))break;return mergedLoaderData}function findNearestBoundary(matches,routeId){return(routeId?matches.slice(0,matches.findIndex(m=>m.route.id===routeId)+1):[...matches]).reverse().find(m=>!0===m.route.hasErrorBoundary)||matches[0]}
function getShortCircuitMatches(routes){routes=1===routes.length?routes[0]:routes.find(r=>r.index||!r.path||"/"===r.path)||{id:"__shim-error-route__"};return{matches:[{params:{},pathname:"",pathnameBase:"",route:routes}],route:routes}}function getInternalRouterError(status,_temp5){let {pathname,routeId,method,type}=void 0===_temp5?{}:_temp5;_temp5="Unknown Server Error";let errorMessage="Unknown @remix-run/router error";400===status?(_temp5="Bad Request",method&&pathname&&routeId?errorMessage="You made a "+
method+' request to "'+pathname+'" but did not provide a `loader` for route "'+(routeId+'", so there is no way to handle the request.'):"defer-action"===type?errorMessage="defer() is not supported in actions":"invalid-body"===type&&(errorMessage="Unable to encode submission body")):403===status?(_temp5="Forbidden",errorMessage='Route "'+routeId+'" does not match URL "'+pathname+'"'):404===status?(_temp5="Not Found",errorMessage='No route matches URL "'+pathname+'"'):405===status&&(_temp5="Method Not Allowed",
method&&pathname&&routeId?errorMessage="You made a "+method.toUpperCase()+' request to "'+pathname+'" but did not provide an `action` for route "'+(routeId+'", so there is no way to handle the request.'):method&&(errorMessage='Invalid request method "'+method.toUpperCase()+'"'));return new ErrorResponseImpl(status||500,_temp5,Error(errorMessage),!0)}function findRedirect(results){for(let i=results.length-1;0<=i;i--){let result=results[i];if(isRedirectResult(result))return{result,idx:i}}}function stripHashFromPath(path){path=
"string"===typeof path?parsePath(path):path;return createPath(_extends({},path,{hash:""}))}function isDeferredResult(result){return result.type===ResultType.deferred}function isErrorResult(result){return result.type===ResultType.error}function isRedirectResult(result){return(result&&result.type)===ResultType.redirect}function isDeferredData(value){return value&&"object"===typeof value&&"object"===typeof value.data&&"function"===typeof value.subscribe&&"function"===typeof value.cancel&&"function"===
typeof value.resolveData}function isResponse(value){return null!=value&&"number"===typeof value.status&&"string"===typeof value.statusText&&"object"===typeof value.headers&&"undefined"!==typeof value.body}function isMutationMethod(method){return validMutationMethods.has(method.toLowerCase())}async function resolveDeferredResults(currentMatches,matchesToLoad,results,signals,isFetcher,currentLoaderData){for(let index=0;index<results.length;index++){let result$jscomp$0=results[index],match=matchesToLoad[index];
if(match){var currentMatch=currentMatches.find(m=>m.route.id===match.route.id);currentMatch=null!=currentMatch&&!isNewRouteInstance(currentMatch,match)&&void 0!==(currentLoaderData&&currentLoaderData[match.route.id]);isDeferredResult(result$jscomp$0)&&(isFetcher||currentMatch)&&(currentMatch=signals[index],invariant(currentMatch,"Expected an AbortSignal for revalidating fetcher deferred result"),await resolveDeferredData(result$jscomp$0,currentMatch,isFetcher).then(result=>{result&&(results[index]=
result||results[index])}))}}}async function resolveDeferredData(result,signal,unwrap){void 0===unwrap&&(unwrap=!1);if(!await result.deferredData.resolveData(signal)){if(unwrap)try{return{type:ResultType.data,data:result.deferredData.unwrappedData}}catch(e){return{type:ResultType.error,error:e}}return{type:ResultType.data,data:result.deferredData.data}}}function hasNakedIndexQuery(search){return(new URLSearchParams(search)).getAll("index").some(v=>""===v)}function getTargetMatch(matches,location){location=
"string"===typeof location?parsePath(location).search:location.search;if(matches[matches.length-1].route.index&&hasNakedIndexQuery(location||""))return matches[matches.length-1];matches=getPathContributingMatches(matches);return matches[matches.length-1]}function getSubmissionFromNavigation(navigation){let {formMethod,formAction,formEncType,text,formData,json}=navigation;if(formMethod&&formAction&&formEncType){if(null!=text)return{formMethod,formAction,formEncType,formData:void 0,json:void 0,text};
if(null!=formData)return{formMethod,formAction,formEncType,formData,json:void 0,text:void 0};if(void 0!==json)return{formMethod,formAction,formEncType,formData:void 0,json,text:void 0}}}function getLoadingNavigation(location,submission){return submission?{state:"loading",location,formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text}:{state:"loading",location,formMethod:void 0,formAction:void 0,
formEncType:void 0,formData:void 0,json:void 0,text:void 0}}function getLoadingFetcher(submission,data){return submission?{state:"loading",formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text,data}:{state:"loading",formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0,data}}function getDoneFetcher(data){return{state:"idle",formMethod:void 0,
formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0,data}}function restoreAppliedTransitions(_window,transitions){try{let sessionPositions=_window.sessionStorage.getItem("remix-router-transitions");if(sessionPositions){let json=JSON.parse(sessionPositions);for(let [k,v]of Object.entries(json||{}))v&&Array.isArray(v)&&transitions.set(k,new Set(v||[]))}}catch(e){}}Object.defineProperty(exports,"__esModule",{value:!0});let Action=function(Action){Action.Pop="POP";Action.Push=
"PUSH";Action.Replace="REPLACE";return Action}({}),ResultType=function(ResultType){ResultType.data="data";ResultType.deferred="deferred";ResultType.redirect="redirect";ResultType.error="error";return ResultType}({});const immutableRouteKeys=new Set("lazy caseSensitive path id index children".split(" ")),paramRe=/^:\w+$/,isSplat=s=>"*"===s,joinPaths=paths=>paths.join("/").replace(/\/\/+/g,"/"),normalizePathname=pathname=>pathname.replace(/\/+$/,"").replace(/^\/*/,"/");class AbortedDeferredError extends Error{}
class DeferredData{constructor(data,responseInit){this.pendingKeysSet=new Set;this.subscribers=new Set;this.deferredKeys=[];invariant(data&&"object"===typeof data&&!Array.isArray(data),"defer() only accepts plain objects");let reject;this.abortPromise=new Promise((_,r)=>reject=r);this.controller=new AbortController;let onAbort=()=>reject(new AbortedDeferredError("Deferred data aborted"));this.unlistenAbortSignal=()=>this.controller.signal.removeEventListener("abort",onAbort);this.controller.signal.addEventListener("abort",
onAbort);this.data=Object.entries(data).reduce((acc,_ref2)=>{let [key,value]=_ref2;return Object.assign(acc,{[key]:this.trackPromise(key,value)})},{});this.done&&this.unlistenAbortSignal();this.init=responseInit}trackPromise(key,value){if(!(value instanceof Promise))return value;this.deferredKeys.push(key);this.pendingKeysSet.add(key);let promise=Promise.race([value,this.abortPromise]).then(data=>this.onSettle(promise,key,void 0,data),error=>this.onSettle(promise,key,error));promise.catch(()=>{});
Object.defineProperty(promise,"_tracked",{get:()=>!0});return promise}onSettle(promise,key,error,data){if(this.controller.signal.aborted&&error instanceof AbortedDeferredError)return this.unlistenAbortSignal(),Object.defineProperty(promise,"_error",{get:()=>error}),Promise.reject(error);this.pendingKeysSet.delete(key);this.done&&this.unlistenAbortSignal();if(void 0===error&&void 0===data){let undefinedError=Error('Deferred data for key "'+key+'" resolved/rejected with `undefined`, you must resolve/reject with a value or `null`.');
Object.defineProperty(promise,"_error",{get:()=>undefinedError});this.emit(!1,key);return Promise.reject(undefinedError)}if(void 0===data)return Object.defineProperty(promise,"_error",{get:()=>error}),this.emit(!1,key),Promise.reject(error);Object.defineProperty(promise,"_data",{get:()=>data});this.emit(!1,key);return data}emit(aborted,settledKey){this.subscribers.forEach(subscriber=>subscriber(aborted,settledKey))}subscribe(fn){this.subscribers.add(fn);return()=>this.subscribers.delete(fn)}cancel(){this.controller.abort();
this.pendingKeysSet.forEach((v,k)=>this.pendingKeysSet.delete(k));this.emit(!0)}async resolveData(signal){let aborted$jscomp$0=!1;if(!this.done){let onAbort=()=>this.cancel();signal.addEventListener("abort",onAbort);aborted$jscomp$0=await new Promise(resolve=>{this.subscribe(aborted=>{signal.removeEventListener("abort",onAbort);(aborted||this.done)&&resolve(aborted)})})}return aborted$jscomp$0}get done(){return 0===this.pendingKeysSet.size}get unwrappedData(){invariant(null!==this.data&&this.done,
"Can only unwrap data on initialized and settled deferreds");return Object.entries(this.data).reduce((acc,_ref3)=>{let [key,value]=_ref3;_ref3=Object;var JSCompiler_temp_const=_ref3.assign;if(value instanceof Promise&&!0===value._tracked){if(value._error)throw value._error;var JSCompiler_inline_result=value._data}else JSCompiler_inline_result=value;return JSCompiler_temp_const.call(_ref3,acc,{[key]:JSCompiler_inline_result})},{})}get pendingKeys(){return Array.from(this.pendingKeysSet)}}const redirect=
function(url,init){void 0===init&&(init=302);"number"===typeof init?init={status:init}:"undefined"===typeof init.status&&(init.status=302);let headers=new Headers(init.headers);headers.set("Location",url);return new Response(null,_extends({},init,{headers}))};class ErrorResponseImpl{constructor(status,statusText,data,internal){void 0===internal&&(internal=!1);this.status=status;this.statusText=statusText||"";this.internal=internal;data instanceof Error?(this.data=data.toString(),this.error=data):
this.data=data}}global=["post","put","patch","delete"];const validMutationMethods=new Set(global);global=["get",...global];const validRequestMethods=new Set(global),redirectStatusCodes=new Set([301,302,303,307,308]),redirectPreserveMethodStatusCodes=new Set([307,308]),IDLE_NAVIGATION={state:"idle",location:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0},IDLE_FETCHER={state:"idle",data:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,
formData:void 0,json:void 0,text:void 0},IDLE_BLOCKER={state:"unblocked",proceed:void 0,reset:void 0,location:void 0},ABSOLUTE_URL_REGEX=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,defaultMapRouteProperties=route=>({hasErrorBoundary:!!route.hasErrorBoundary}),UNSAFE_DEFERRED_SYMBOL=Symbol("deferred");exports.AbortedDeferredError=AbortedDeferredError;exports.Action=Action;exports.IDLE_BLOCKER=IDLE_BLOCKER;exports.IDLE_FETCHER=IDLE_FETCHER;exports.IDLE_NAVIGATION=IDLE_NAVIGATION;exports.UNSAFE_DEFERRED_SYMBOL=
UNSAFE_DEFERRED_SYMBOL;exports.UNSAFE_DeferredData=DeferredData;exports.UNSAFE_ErrorResponseImpl=ErrorResponseImpl;exports.UNSAFE_convertRouteMatchToUiMatch=convertRouteMatchToUiMatch;exports.UNSAFE_convertRoutesToDataRoutes=convertRoutesToDataRoutes;exports.UNSAFE_getPathContributingMatches=getPathContributingMatches;exports.UNSAFE_invariant=invariant;exports.UNSAFE_warning=warning;exports.createBrowserHistory=function(options){void 0===options&&(options={});return getUrlBasedHistory(function(window,
globalHistory){let {pathname,search,hash}=window.location;return createLocation("",{pathname,search,hash},globalHistory.state&&globalHistory.state.usr||null,globalHistory.state&&globalHistory.state.key||"default")},function(window,to){return"string"===typeof to?to:createPath(to)},null,options)};exports.createHashHistory=function(options){void 0===options&&(options={});return getUrlBasedHistory(function(window,globalHistory){let {pathname="/",search="",hash=""}=parsePath(window.location.hash.substr(1));
pathname.startsWith("/")||pathname.startsWith(".")||(pathname="/"+pathname);return createLocation("",{pathname,search,hash},globalHistory.state&&globalHistory.state.usr||null,globalHistory.state&&globalHistory.state.key||"default")},function(window,to){var base=window.document.querySelector("base");let href="";base&&base.getAttribute("href")&&(window=window.location.href,base=window.indexOf("#"),href=-1===base?window:window.slice(0,base));return href+"#"+("string"===typeof to?to:createPath(to))},
function(location,to){warning("/"===location.pathname.charAt(0),"relative pathnames are not supported in hash history.push("+JSON.stringify(to)+")")},options)};exports.createMemoryHistory=function(options){function createMemoryLocation(to,state,key){void 0===state&&(state=null);state=createLocation(entries?entries[index$jscomp$0].pathname:"/",to,state,key);warning("/"===state.pathname.charAt(0),"relative pathnames are not supported in memory history: "+JSON.stringify(to));return state}function createHref(to){return"string"===
typeof to?to:createPath(to)}void 0===options&&(options={});let {initialEntries=["/"],initialIndex,v5Compat=!1}=options,entries;entries=initialEntries.map((entry,index)=>createMemoryLocation(entry,"string"===typeof entry?null:entry.state,0===index?"default":void 0));let index$jscomp$0=Math.min(Math.max(null==initialIndex?entries.length-1:initialIndex,0),entries.length-1),action=Action.Pop,listener=null;return{get index(){return index$jscomp$0},get action(){return action},get location(){return entries[index$jscomp$0]},
createHref,createURL(to){return new URL(createHref(to),"http://localhost")},encodeLocation(to){to="string"===typeof to?parsePath(to):to;return{pathname:to.pathname||"",search:to.search||"",hash:to.hash||""}},push(to,state){action=Action.Push;to=createMemoryLocation(to,state);index$jscomp$0+=1;entries.splice(index$jscomp$0,entries.length,to);v5Compat&&listener&&listener({action,location:to,delta:1})},replace(to,state){action=Action.Replace;to=createMemoryLocation(to,state);entries[index$jscomp$0]=
to;v5Compat&&listener&&listener({action,location:to,delta:0})},go(delta){action=Action.Pop;let nextIndex=Math.min(Math.max(index$jscomp$0+delta,0),entries.length-1),nextLocation=entries[nextIndex];index$jscomp$0=nextIndex;listener&&listener({action,location:nextLocation,delta})},listen(fn){listener=fn;return()=>{listener=null}}}};exports.createPath=createPath;exports.createRouter=function(init){function updateState(newState,opts){void 0===opts&&(opts={});state$jscomp$0=_extends({},state$jscomp$0,
newState);let completedFetchers=[],deletedFetchersKeys=[];future.v7_fetcherPersist&&state$jscomp$0.fetchers.forEach((fetcher,key)=>{"idle"===fetcher.state&&(deletedFetchers.has(key)?deletedFetchersKeys.push(key):completedFetchers.push(key))});[...subscribers].forEach(subscriber=>subscriber(state$jscomp$0,{deletedFetchers:deletedFetchersKeys,unstable_viewTransitionOpts:opts.viewTransitionOpts,unstable_flushSync:!0===opts.flushSync}));future.v7_fetcherPersist&&(completedFetchers.forEach(key=>state$jscomp$0.fetchers.delete(key)),
deletedFetchersKeys.forEach(key=>deleteFetcher(key)))}function completeNavigation(location,newState,_temp){var _location$state,_location$state2;({flushSync:_temp}=void 0===_temp?{}:_temp);var isActionReload=null!=state$jscomp$0.actionData&&null!=state$jscomp$0.navigation.formMethod&&isMutationMethod(state$jscomp$0.navigation.formMethod)&&"loading"===state$jscomp$0.navigation.state&&!0!==(null==(_location$state=location.state)?void 0:_location$state._isRedirect);_location$state=newState.actionData?
0<Object.keys(newState.actionData).length?newState.actionData:null:isActionReload?state$jscomp$0.actionData:null;isActionReload=newState.loaderData?mergeLoaderData(state$jscomp$0.loaderData,newState.loaderData,newState.matches||[],newState.errors):state$jscomp$0.loaderData;let blockers=state$jscomp$0.blockers;0<blockers.size&&(blockers=new Map(blockers),blockers.forEach((_,k)=>blockers.set(k,IDLE_BLOCKER)));let preventScrollReset=!0===pendingPreventScrollReset||null!=state$jscomp$0.navigation.formMethod&&
isMutationMethod(state$jscomp$0.navigation.formMethod)&&!0!==(null==(_location$state2=location.state)?void 0:_location$state2._isRedirect);inFlightDataRoutes&&(dataRoutes=inFlightDataRoutes,inFlightDataRoutes=void 0);isUninterruptedRevalidation||pendingAction!==Action.Pop&&(pendingAction===Action.Push?init.history.push(location,location.state):pendingAction===Action.Replace&&init.history.replace(location,location.state));var viewTransitionOpts;pendingAction===Action.Pop?(_location$state2=appliedViewTransitions.get(state$jscomp$0.location.pathname))&&
_location$state2.has(location.pathname)?viewTransitionOpts={currentLocation:state$jscomp$0.location,nextLocation:location}:appliedViewTransitions.has(location.pathname)&&(viewTransitionOpts={currentLocation:location,nextLocation:state$jscomp$0.location}):pendingViewTransitionEnabled&&((viewTransitionOpts=appliedViewTransitions.get(state$jscomp$0.location.pathname))?viewTransitionOpts.add(location.pathname):(viewTransitionOpts=new Set([location.pathname]),appliedViewTransitions.set(state$jscomp$0.location.pathname,
viewTransitionOpts)),viewTransitionOpts={currentLocation:state$jscomp$0.location,nextLocation:location});updateState(_extends({},newState,{actionData:_location$state,loaderData:isActionReload,historyAction:pendingAction,location,initialized:!0,navigation:IDLE_NAVIGATION,revalidation:"idle",restoreScrollPosition:getSavedScrollPosition(location,newState.matches||state$jscomp$0.matches),preventScrollReset,blockers}),{viewTransitionOpts,flushSync:!0===_temp});pendingAction=Action.Pop;isRevalidationRequired=
isUninterruptedRevalidation=pendingViewTransitionEnabled=pendingPreventScrollReset=!1;cancelledDeferredRoutes=[];cancelledFetcherLoads=[]}async function navigate(to,opts){if("number"===typeof to)init.history.go(to);else{var normalizedPath=normalizeTo(state$jscomp$0.location,state$jscomp$0.matches,basename,future.v7_prependBasename,to,null==opts?void 0:opts.fromRouteId,null==opts?void 0:opts.relative),{path,submission,error}=normalizeNavigateOptions(future.v7_normalizeFormMethod,!1,normalizedPath,
opts);normalizedPath=state$jscomp$0.location;var nextLocation=createLocation(state$jscomp$0.location,path,opts&&opts.state);nextLocation=_extends({},nextLocation,init.history.encodeLocation(nextLocation));var userReplace=opts&&null!=opts.replace?opts.replace:void 0,historyAction=Action.Push;!0===userReplace?historyAction=Action.Replace:!1!==userReplace&&null!=submission&&isMutationMethod(submission.formMethod)&&submission.formAction===state$jscomp$0.location.pathname+state$jscomp$0.location.search&&
(historyAction=Action.Replace);userReplace=opts&&"preventScrollReset"in opts?!0===opts.preventScrollReset:void 0;var flushSync=!0===(opts&&opts.unstable_flushSync),blockerKey=shouldBlockNavigation({currentLocation:normalizedPath,nextLocation,historyAction});if(blockerKey)updateBlocker(blockerKey,{state:"blocked",location:nextLocation,proceed(){updateBlocker(blockerKey,{state:"proceeding",proceed:void 0,reset:void 0,location:nextLocation});navigate(to,opts)},reset(){let blockers=new Map(state$jscomp$0.blockers);
blockers.set(blockerKey,IDLE_BLOCKER);updateState({blockers})}});else return await startNavigation(historyAction,nextLocation,{submission,pendingError:error,preventScrollReset:userReplace,replace:opts&&opts.replace,enableViewTransition:opts&&opts.unstable_viewTransition,flushSync})}}async function startNavigation(historyAction,location,opts){pendingNavigationController&&pendingNavigationController.abort();pendingNavigationController=null;pendingAction=historyAction;isUninterruptedRevalidation=!0===
(opts&&opts.startUninterruptedRevalidation);savedScrollPositions&&getScrollPosition&&(historyAction=getScrollKey(state$jscomp$0.location,state$jscomp$0.matches),savedScrollPositions[historyAction]=getScrollPosition());pendingPreventScrollReset=!0===(opts&&opts.preventScrollReset);pendingViewTransitionEnabled=!0===(opts&&opts.enableViewTransition);var routesToUse=inFlightDataRoutes||dataRoutes;let loadingNavigation=opts&&opts.overrideNavigation;historyAction=matchRoutes(routesToUse,location,basename);
let flushSync=!0===(opts&&opts.flushSync);if(historyAction)if((routesToUse=!state$jscomp$0.initialized||isRevalidationRequired)||(routesToUse=state$jscomp$0.location,routesToUse=!(routesToUse.pathname!==location.pathname||routesToUse.search!==location.search?0:""===routesToUse.hash?""!==location.hash:routesToUse.hash===location.hash||""!==location.hash)),routesToUse||opts&&opts.submission&&isMutationMethod(opts.submission.formMethod)){pendingNavigationController=new AbortController;routesToUse=createClientSideRequest(init.history,
location,pendingNavigationController.signal,opts&&opts.submission);if(opts&&opts.pendingError)var pendingError={[findNearestBoundary(historyAction).route.id]:opts.pendingError};else if(opts&&opts.submission&&isMutationMethod(opts.submission.formMethod)){pendingError=await handleAction(routesToUse,location,opts.submission,historyAction,{replace:opts.replace,flushSync});if(pendingError.shortCircuited)return;var pendingActionData=pendingError.pendingActionData;pendingError=pendingError.pendingActionError;
loadingNavigation=getLoadingNavigation(location,opts.submission);flushSync=!1;routesToUse=new Request(routesToUse.url,{signal:routesToUse.signal})}var {shortCircuited,loaderData,errors}=await handleLoaders(routesToUse,location,historyAction,loadingNavigation,opts&&opts.submission,opts&&opts.fetcherSubmission,opts&&opts.replace,flushSync,pendingActionData,pendingError);shortCircuited||(pendingNavigationController=null,completeNavigation(location,_extends({matches:historyAction},pendingActionData?{actionData:pendingActionData}:
{},{loaderData,errors})))}else completeNavigation(location,{matches:historyAction},{flushSync});else{opts=getInternalRouterError(404,{pathname:location.pathname});let {matches:notFoundMatches,route}=getShortCircuitMatches(routesToUse);cancelActiveDeferreds();completeNavigation(location,{matches:notFoundMatches,loaderData:{},errors:{[route.id]:opts}},{flushSync})}}async function handleAction(request,location,submission,matches,opts){void 0===opts&&(opts={});interruptActiveLoads();updateState({navigation:{state:"submitting",
location,formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text}},{flushSync:!0===opts.flushSync});let actionMatch=getTargetMatch(matches,location);if(actionMatch.route.action||actionMatch.route.lazy){if(location=await callLoaderOrAction("action",request,actionMatch,matches,manifest,mapRouteProperties,basename),request.signal.aborted)return{shortCircuited:!0}}else location={type:ResultType.error,
error:getInternalRouterError(405,{method:request.method,pathname:location.pathname,routeId:actionMatch.route.id})};if(isRedirectResult(location))return await startRedirectNavigation(state$jscomp$0,location,{submission,replace:opts&&null!=opts.replace?opts.replace:location.location===state$jscomp$0.location.pathname+state$jscomp$0.location.search}),{shortCircuited:!0};if(isErrorResult(location))return request=findNearestBoundary(matches,actionMatch.route.id),!0!==(opts&&opts.replace)&&(pendingAction=
Action.Push),{pendingActionData:{},pendingActionError:{[request.route.id]:location.error}};if(isDeferredResult(location))throw getInternalRouterError(400,{type:"defer-action"});return{pendingActionData:{[actionMatch.route.id]:location.data}}}async function handleLoaders(request,location,matches,overrideNavigation,submission,fetcherSubmission,replace,flushSync,pendingActionData,pendingError){overrideNavigation=overrideNavigation||getLoadingNavigation(location,submission);submission=submission||fetcherSubmission||
getSubmissionFromNavigation(overrideNavigation);let [matchesToLoad,revalidatingFetchers]=getMatchesToLoad(init.history,state$jscomp$0,matches,submission,location,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,deletedFetchers,fetchLoadMatches,fetchRedirectIds,inFlightDataRoutes||dataRoutes,basename,pendingActionData,pendingError);cancelActiveDeferreds(routeId=>!(matches&&matches.some(m=>m.route.id===routeId))||matchesToLoad&&matchesToLoad.some(m=>m.route.id===routeId));pendingNavigationLoadId=
++incrementingLoadId;if(0===matchesToLoad.length&&0===revalidatingFetchers.length)return replace=markFetchRedirectsDone(),completeNavigation(location,_extends({matches,loaderData:{},errors:pendingError||null},pendingActionData?{actionData:pendingActionData}:{},replace?{fetchers:new Map(state$jscomp$0.fetchers)}:{}),{flushSync}),{shortCircuited:!0};isUninterruptedRevalidation||(revalidatingFetchers.forEach(rf=>{var fetcher=state$jscomp$0.fetchers.get(rf.key);fetcher=getLoadingFetcher(void 0,fetcher?
fetcher.data:void 0);state$jscomp$0.fetchers.set(rf.key,fetcher)}),location=pendingActionData||state$jscomp$0.actionData,updateState(_extends({navigation:overrideNavigation},location?0===Object.keys(location).length?{actionData:null}:{actionData:location}:{},0<revalidatingFetchers.length?{fetchers:new Map(state$jscomp$0.fetchers)}:{}),{flushSync}));revalidatingFetchers.forEach(rf=>{fetchControllers.has(rf.key)&&abortFetcher(rf.key);rf.controller&&fetchControllers.set(rf.key,rf.controller)});flushSync=
()=>revalidatingFetchers.forEach(f=>abortFetcher(f.key));pendingNavigationController&&pendingNavigationController.signal.addEventListener("abort",flushSync);let {results,loaderResults,fetcherResults}=await callLoadersAndMaybeResolveData(state$jscomp$0.matches,matches,matchesToLoad,revalidatingFetchers,request);if(request.signal.aborted)return{shortCircuited:!0};pendingNavigationController&&pendingNavigationController.signal.removeEventListener("abort",flushSync);revalidatingFetchers.forEach(rf=>fetchControllers.delete(rf.key));
if(request=findRedirect(results))return request.idx>=matchesToLoad.length&&fetchRedirectIds.add(revalidatingFetchers[request.idx-matchesToLoad.length].key),await startRedirectNavigation(state$jscomp$0,request.result,{replace}),{shortCircuited:!0};let {loaderData,errors}=processLoaderData(state$jscomp$0,matches,matchesToLoad,loaderResults,pendingError,revalidatingFetchers,fetcherResults,activeDeferreds);activeDeferreds.forEach((deferredData,routeId)=>{deferredData.subscribe(aborted=>{(aborted||deferredData.done)&&
activeDeferreds.delete(routeId)})});pendingError=markFetchRedirectsDone();replace=abortStaleFetchLoads(pendingNavigationLoadId);return _extends({loaderData,errors},pendingError||replace||0<revalidatingFetchers.length?{fetchers:new Map(state$jscomp$0.fetchers)}:{})}async function handleFetcherAction(key,routeId,path,match,requestMatches,flushSync,submission){interruptActiveLoads();fetchLoadMatches.delete(key);if(match.route.action||match.route.lazy){var existingFetcher=state$jscomp$0.fetchers.get(key);
updateFetcherState(key,{state:"submitting",formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text,data:existingFetcher?existingFetcher.data:void 0},{flushSync});flushSync=new AbortController;path=createClientSideRequest(init.history,path,flushSync.signal,submission);fetchControllers.set(key,flushSync);existingFetcher=incrementingLoadId;requestMatches=await callLoaderOrAction("action",
path,match,requestMatches,manifest,mapRouteProperties,basename);if(path.signal.aborted)fetchControllers.get(key)===flushSync&&fetchControllers.delete(key);else if(deletedFetchers.has(key))updateFetcherState(key,getDoneFetcher(void 0));else{if(isRedirectResult(requestMatches)){fetchControllers.delete(key);if(pendingNavigationLoadId>existingFetcher){updateFetcherState(key,getDoneFetcher(void 0));return}fetchRedirectIds.add(key);updateFetcherState(key,getLoadingFetcher(submission));return startRedirectNavigation(state$jscomp$0,
requestMatches,{fetcherSubmission:submission})}if(isErrorResult(requestMatches))setFetcherError(key,routeId,requestMatches.error);else{if(isDeferredResult(requestMatches))throw getInternalRouterError(400,{type:"defer-action"});var nextLocation=state$jscomp$0.navigation.location||state$jscomp$0.location;existingFetcher=createClientSideRequest(init.history,nextLocation,flushSync.signal);var routesToUse=inFlightDataRoutes||dataRoutes;routeId="idle"!==state$jscomp$0.navigation.state?matchRoutes(routesToUse,
state$jscomp$0.navigation.location,basename):state$jscomp$0.matches;invariant(routeId,"Didn't find any matches after fetcher action");path=++incrementingLoadId;fetchReloadIds.set(key,path);var loadFetcher=getLoadingFetcher(submission,requestMatches.data);state$jscomp$0.fetchers.set(key,loadFetcher);var [matchesToLoad,revalidatingFetchers]=getMatchesToLoad(init.history,state$jscomp$0,routeId,submission,nextLocation,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,deletedFetchers,
fetchLoadMatches,fetchRedirectIds,routesToUse,basename,{[match.route.id]:requestMatches.data},void 0);revalidatingFetchers.filter(rf=>rf.key!==key).forEach(rf=>{let staleKey=rf.key;var existingFetcher=state$jscomp$0.fetchers.get(staleKey);existingFetcher=getLoadingFetcher(void 0,existingFetcher?existingFetcher.data:void 0);state$jscomp$0.fetchers.set(staleKey,existingFetcher);fetchControllers.has(staleKey)&&abortFetcher(staleKey);rf.controller&&fetchControllers.set(staleKey,rf.controller)});updateState({fetchers:new Map(state$jscomp$0.fetchers)});
match=()=>revalidatingFetchers.forEach(rf=>abortFetcher(rf.key));flushSync.signal.addEventListener("abort",match);var {results,loaderResults,fetcherResults}=await callLoadersAndMaybeResolveData(state$jscomp$0.matches,routeId,matchesToLoad,revalidatingFetchers,existingFetcher);if(!flushSync.signal.aborted){flushSync.signal.removeEventListener("abort",match);fetchReloadIds.delete(key);fetchControllers.delete(key);revalidatingFetchers.forEach(r=>fetchControllers.delete(r.key));if(match=findRedirect(results))return match.idx>=
matchesToLoad.length&&fetchRedirectIds.add(revalidatingFetchers[match.idx-matchesToLoad.length].key),startRedirectNavigation(state$jscomp$0,match.result);var {loaderData,errors}=processLoaderData(state$jscomp$0,state$jscomp$0.matches,matchesToLoad,loaderResults,void 0,revalidatingFetchers,fetcherResults,activeDeferreds);state$jscomp$0.fetchers.has(key)&&(match=getDoneFetcher(requestMatches.data),state$jscomp$0.fetchers.set(key,match));abortStaleFetchLoads(path);"loading"===state$jscomp$0.navigation.state&&
path>pendingNavigationLoadId?(invariant(pendingAction,"Expected pending action"),pendingNavigationController&&pendingNavigationController.abort(),completeNavigation(state$jscomp$0.navigation.location,{matches:routeId,loaderData,errors,fetchers:new Map(state$jscomp$0.fetchers)})):(updateState({errors,loaderData:mergeLoaderData(state$jscomp$0.loaderData,loaderData,routeId,errors),fetchers:new Map(state$jscomp$0.fetchers)}),isRevalidationRequired=!1)}}}}else match=getInternalRouterError(405,{method:submission.formMethod,
pathname:path,routeId}),setFetcherError(key,routeId,match,{flushSync})}async function handleFetcherLoader(key,routeId,path,match,matches,flushSync,submission){let existingFetcher=state$jscomp$0.fetchers.get(key);updateFetcherState(key,getLoadingFetcher(submission,existingFetcher?existingFetcher.data:void 0),{flushSync});flushSync=new AbortController;path=createClientSideRequest(init.history,path,flushSync.signal);fetchControllers.set(key,flushSync);submission=incrementingLoadId;match=await callLoaderOrAction("loader",
path,match,matches,manifest,mapRouteProperties,basename);isDeferredResult(match)&&(match=await resolveDeferredData(match,path.signal,!0)||match);fetchControllers.get(key)===flushSync&&fetchControllers.delete(key);path.signal.aborted||(deletedFetchers.has(key)?updateFetcherState(key,getDoneFetcher(void 0)):isRedirectResult(match)?pendingNavigationLoadId>submission?updateFetcherState(key,getDoneFetcher(void 0)):(fetchRedirectIds.add(key),await startRedirectNavigation(state$jscomp$0,match)):isErrorResult(match)?
setFetcherError(key,routeId,match.error):(invariant(!isDeferredResult(match),"Unhandled fetcher deferred data"),updateFetcherState(key,getDoneFetcher(match.data))))}async function startRedirectNavigation(state,redirect,_temp2){let {submission,fetcherSubmission,replace}=void 0===_temp2?{}:_temp2;redirect.revalidate&&(isRevalidationRequired=!0);_temp2=createLocation(state.location,redirect.location,{_isRedirect:!0});invariant(_temp2,"Expected a location on the redirect navigation");if(isBrowser){var isDocumentReload=
!1;redirect.reloadDocument?isDocumentReload=!0:ABSOLUTE_URL_REGEX.test(redirect.location)&&(isDocumentReload=init.history.createURL(redirect.location),isDocumentReload=isDocumentReload.origin!==routerWindow.location.origin||null==stripBasename(isDocumentReload.pathname,basename));if(isDocumentReload){replace?routerWindow.location.replace(redirect.location):routerWindow.location.assign(redirect.location);return}}pendingNavigationController=null;isDocumentReload=!0===replace?Action.Replace:Action.Push;
let {formMethod,formAction,formEncType}=state.navigation;!submission&&!fetcherSubmission&&formMethod&&formAction&&formEncType&&(submission=getSubmissionFromNavigation(state.navigation));state=submission||fetcherSubmission;redirectPreserveMethodStatusCodes.has(redirect.status)&&state&&isMutationMethod(state.formMethod)?await startNavigation(isDocumentReload,_temp2,{submission:_extends({},state,{formAction:redirect.location}),preventScrollReset:pendingPreventScrollReset}):(redirect=getLoadingNavigation(_temp2,
submission),await startNavigation(isDocumentReload,_temp2,{overrideNavigation:redirect,fetcherSubmission,preventScrollReset:pendingPreventScrollReset}))}async function callLoadersAndMaybeResolveData(currentMatches,matches,matchesToLoad,fetchersToLoad,request){let results=await Promise.all([...matchesToLoad.map(match=>callLoaderOrAction("loader",request,match,matches,manifest,mapRouteProperties,basename)),...fetchersToLoad.map(f=>f.matches&&f.match&&f.controller?callLoaderOrAction("loader",createClientSideRequest(init.history,
f.path,f.controller.signal),f.match,f.matches,manifest,mapRouteProperties,basename):{type:ResultType.error,error:getInternalRouterError(404,{pathname:f.path})})]),loaderResults=results.slice(0,matchesToLoad.length),fetcherResults=results.slice(matchesToLoad.length);await Promise.all([resolveDeferredResults(currentMatches,matchesToLoad,loaderResults,loaderResults.map(()=>request.signal),!1,state$jscomp$0.loaderData),resolveDeferredResults(currentMatches,fetchersToLoad.map(f=>f.match),fetcherResults,
fetchersToLoad.map(f=>f.controller?f.controller.signal:null),!0)]);return{results,loaderResults,fetcherResults}}function interruptActiveLoads(){isRevalidationRequired=!0;cancelledDeferredRoutes.push(...cancelActiveDeferreds());fetchLoadMatches.forEach((_,key)=>{fetchControllers.has(key)&&(cancelledFetcherLoads.push(key),abortFetcher(key))})}function updateFetcherState(key,fetcher,opts){void 0===opts&&(opts={});state$jscomp$0.fetchers.set(key,fetcher);updateState({fetchers:new Map(state$jscomp$0.fetchers)},
{flushSync:!0===(opts&&opts.flushSync)})}function setFetcherError(key,routeId,error,opts){void 0===opts&&(opts={});routeId=findNearestBoundary(state$jscomp$0.matches,routeId);deleteFetcher(key);updateState({errors:{[routeId.route.id]:error},fetchers:new Map(state$jscomp$0.fetchers)},{flushSync:!0===(opts&&opts.flushSync)})}function getFetcher(key){future.v7_fetcherPersist&&(activeFetchers.set(key,(activeFetchers.get(key)||0)+1),deletedFetchers.has(key)&&deletedFetchers.delete(key));return state$jscomp$0.fetchers.get(key)||
IDLE_FETCHER}function deleteFetcher(key){let fetcher=state$jscomp$0.fetchers.get(key);!fetchControllers.has(key)||fetcher&&"loading"===fetcher.state&&fetchReloadIds.has(key)||abortFetcher(key);fetchLoadMatches.delete(key);fetchReloadIds.delete(key);fetchRedirectIds.delete(key);deletedFetchers.delete(key);state$jscomp$0.fetchers.delete(key)}function abortFetcher(key){let controller=fetchControllers.get(key);invariant(controller,"Expected fetch controller: "+key);controller.abort();fetchControllers.delete(key)}
function markFetchersDone(keys){for(let key of keys)keys=getFetcher(key),keys=getDoneFetcher(keys.data),state$jscomp$0.fetchers.set(key,keys)}function markFetchRedirectsDone(){let doneKeys=[],updatedFetchers=!1;for(let key of fetchRedirectIds){let fetcher=state$jscomp$0.fetchers.get(key);invariant(fetcher,"Expected fetcher: "+key);"loading"===fetcher.state&&(fetchRedirectIds.delete(key),doneKeys.push(key),updatedFetchers=!0)}markFetchersDone(doneKeys);return updatedFetchers}function abortStaleFetchLoads(landedId){let yeetedKeys=
[];for(let [key,id]of fetchReloadIds)if(id<landedId){let fetcher=state$jscomp$0.fetchers.get(key);invariant(fetcher,"Expected fetcher: "+key);"loading"===fetcher.state&&(abortFetcher(key),fetchReloadIds.delete(key),yeetedKeys.push(key))}markFetchersDone(yeetedKeys);return 0<yeetedKeys.length}function deleteBlocker(key){state$jscomp$0.blockers.delete(key);blockerFunctions.delete(key)}function updateBlocker(key,newBlocker){var blocker=state$jscomp$0.blockers.get(key)||IDLE_BLOCKER;invariant("unblocked"===
blocker.state&&"blocked"===newBlocker.state||"blocked"===blocker.state&&"blocked"===newBlocker.state||"blocked"===blocker.state&&"proceeding"===newBlocker.state||"blocked"===blocker.state&&"unblocked"===newBlocker.state||"proceeding"===blocker.state&&"unblocked"===newBlocker.state,"Invalid blocker state transition: "+blocker.state+" -\x3e "+newBlocker.state);blocker=new Map(state$jscomp$0.blockers);blocker.set(key,newBlocker);updateState({blockers:blocker})}function shouldBlockNavigation(_ref2){let {currentLocation,
nextLocation,historyAction}=_ref2;if(0!==blockerFunctions.size){1<blockerFunctions.size&&warning(!1,"A router only supports one blocker at a time");_ref2=Array.from(blockerFunctions.entries());var [blockerKey,blockerFunction]=_ref2[_ref2.length-1];_ref2=state$jscomp$0.blockers.get(blockerKey);if((!_ref2||"proceeding"!==_ref2.state)&&blockerFunction({currentLocation,nextLocation,historyAction}))return blockerKey}}function cancelActiveDeferreds(predicate){let cancelledRouteIds=[];activeDeferreds.forEach((dfd,
routeId)=>{if(!predicate||predicate(routeId))dfd.cancel(),cancelledRouteIds.push(routeId),activeDeferreds.delete(routeId)});return cancelledRouteIds}function getScrollKey(location,matches){return getScrollRestorationKey?getScrollRestorationKey(location,matches.map(m=>convertRouteMatchToUiMatch(m,state$jscomp$0.loaderData)))||location.key:location.key}function getSavedScrollPosition(location,matches){return savedScrollPositions&&(location=getScrollKey(location,matches),location=savedScrollPositions[location],
"number"===typeof location)?location:null}const routerWindow=init.window?init.window:"undefined"!==typeof window?window:void 0,isBrowser="undefined"!==typeof routerWindow&&"undefined"!==typeof routerWindow.document&&"undefined"!==typeof routerWindow.document.createElement,isServer=!isBrowser;invariant(0<init.routes.length,"You must provide a non-empty routes array to createRouter");let mapRouteProperties;if(init.mapRouteProperties)mapRouteProperties=init.mapRouteProperties;else if(init.detectErrorBoundary){let detectErrorBoundary=
init.detectErrorBoundary;mapRouteProperties=route=>({hasErrorBoundary:detectErrorBoundary(route)})}else mapRouteProperties=defaultMapRouteProperties;let manifest={},dataRoutes=convertRoutesToDataRoutes(init.routes,mapRouteProperties,void 0,manifest),inFlightDataRoutes,basename=init.basename||"/",future=_extends({v7_fetcherPersist:!1,v7_normalizeFormMethod:!1,v7_prependBasename:!1},init.future),unlistenHistory=null,subscribers=new Set,savedScrollPositions=null,getScrollRestorationKey=null,getScrollPosition=
null,initialScrollRestored=null!=init.hydrationData,initialMatches=matchRoutes(dataRoutes,init.history.location,basename);var initialErrors=null;if(null==initialMatches){initialErrors=getInternalRouterError(404,{pathname:init.history.location.pathname});let {matches,route}=getShortCircuitMatches(dataRoutes);initialMatches=matches;initialErrors={[route.id]:initialErrors}}let initialized=!initialMatches.some(m=>m.route.lazy)&&(!initialMatches.some(m=>m.route.loader)||null!=init.hydrationData),router,
state$jscomp$0={historyAction:init.history.action,location:init.history.location,matches:initialMatches,initialized,navigation:IDLE_NAVIGATION,restoreScrollPosition:null!=init.hydrationData?!1:null,preventScrollReset:!1,revalidation:"idle",loaderData:init.hydrationData&&init.hydrationData.loaderData||{},actionData:init.hydrationData&&init.hydrationData.actionData||null,errors:init.hydrationData&&init.hydrationData.errors||initialErrors,fetchers:new Map,blockers:new Map},pendingAction=Action.Pop,pendingPreventScrollReset=
!1,pendingNavigationController,pendingViewTransitionEnabled=!1,appliedViewTransitions=new Map,removePageHideEventListener=null,isUninterruptedRevalidation=!1,isRevalidationRequired=!1,cancelledDeferredRoutes=[],cancelledFetcherLoads=[],fetchControllers=new Map,incrementingLoadId=0,pendingNavigationLoadId=-1,fetchReloadIds=new Map,fetchRedirectIds=new Set,fetchLoadMatches=new Map,activeFetchers=new Map,deletedFetchers=new Set,activeDeferreds=new Map,blockerFunctions=new Map,ignoreNextHistoryUpdate=
!1;return router={get basename(){return basename},get state(){return state$jscomp$0},get routes(){return dataRoutes},get window(){return routerWindow},initialize:function(){unlistenHistory=init.history.listen(_ref=>{let {action:historyAction,location,delta}=_ref;if(ignoreNextHistoryUpdate)ignoreNextHistoryUpdate=!1;else{warning(0===blockerFunctions.size||null!=delta,"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
var blockerKey=shouldBlockNavigation({currentLocation:state$jscomp$0.location,nextLocation:location,historyAction});if(blockerKey&&null!=delta)ignoreNextHistoryUpdate=!0,init.history.go(-1*delta),updateBlocker(blockerKey,{state:"blocked",location,proceed(){updateBlocker(blockerKey,{state:"proceeding",proceed:void 0,reset:void 0,location});init.history.go(delta)},reset(){let blockers=new Map(state$jscomp$0.blockers);blockers.set(blockerKey,IDLE_BLOCKER);updateState({blockers})}});else return startNavigation(historyAction,
location)}});if(isBrowser){restoreAppliedTransitions(routerWindow,appliedViewTransitions);let _saveAppliedTransitions=()=>{var _window=routerWindow,transitions=appliedViewTransitions;if(0<transitions.size){let json={};for(let [k,v]of transitions)json[k]=[...v];try{_window.sessionStorage.setItem("remix-router-transitions",JSON.stringify(json))}catch(error){warning(!1,"Failed to save applied view transitions in sessionStorage ("+error+").")}}};routerWindow.addEventListener("pagehide",_saveAppliedTransitions);
removePageHideEventListener=()=>routerWindow.removeEventListener("pagehide",_saveAppliedTransitions)}state$jscomp$0.initialized||startNavigation(Action.Pop,state$jscomp$0.location);return router},subscribe:function(fn){subscribers.add(fn);return()=>subscribers.delete(fn)},enableScrollRestoration:function(positions,getPosition,getKey){savedScrollPositions=positions;getScrollPosition=getPosition;getScrollRestorationKey=getKey||null;initialScrollRestored||state$jscomp$0.navigation!==IDLE_NAVIGATION||
(initialScrollRestored=!0,positions=getSavedScrollPosition(state$jscomp$0.location,state$jscomp$0.matches),null!=positions&&updateState({restoreScrollPosition:positions}));return()=>{getScrollRestorationKey=getScrollPosition=savedScrollPositions=null}},navigate,fetch:function(key,routeId,href,opts){if(isServer)throw Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
fetchControllers.has(key)&&abortFetcher(key);let flushSync=!0===(opts&&opts.unstable_flushSync);var routesToUse=inFlightDataRoutes||dataRoutes;href=normalizeTo(state$jscomp$0.location,state$jscomp$0.matches,basename,future.v7_prependBasename,href,routeId,null==opts?void 0:opts.relative);if(routesToUse=matchRoutes(routesToUse,href,basename)){var {path,submission,error}=normalizeNavigateOptions(future.v7_normalizeFormMethod,!0,href,opts);error?setFetcherError(key,routeId,error,{flushSync}):(href=getTargetMatch(routesToUse,
path),pendingPreventScrollReset=!0===(opts&&opts.preventScrollReset),submission&&isMutationMethod(submission.formMethod)?handleFetcherAction(key,routeId,path,href,routesToUse,flushSync,submission):(fetchLoadMatches.set(key,{routeId,path}),handleFetcherLoader(key,routeId,path,href,routesToUse,flushSync,submission)))}else setFetcherError(key,routeId,getInternalRouterError(404,{pathname:href}),{flushSync})},revalidate:function(){interruptActiveLoads();updateState({revalidation:"loading"});"submitting"!==
state$jscomp$0.navigation.state&&("idle"===state$jscomp$0.navigation.state?startNavigation(state$jscomp$0.historyAction,state$jscomp$0.location,{startUninterruptedRevalidation:!0}):startNavigation(pendingAction||state$jscomp$0.historyAction,state$jscomp$0.navigation.location,{overrideNavigation:state$jscomp$0.navigation}))},createHref:to=>init.history.createHref(to),encodeLocation:to=>init.history.encodeLocation(to),getFetcher,deleteFetcher:function(key){if(future.v7_fetcherPersist){let count=(activeFetchers.get(key)||
0)-1;0>=count?(activeFetchers.delete(key),deletedFetchers.add(key)):activeFetchers.set(key,count)}else deleteFetcher(key);updateState({fetchers:new Map(state$jscomp$0.fetchers)})},dispose:function(){unlistenHistory&&unlistenHistory();removePageHideEventListener&&removePageHideEventListener();subscribers.clear();pendingNavigationController&&pendingNavigationController.abort();state$jscomp$0.fetchers.forEach((_,key)=>deleteFetcher(key));state$jscomp$0.blockers.forEach((_,key)=>deleteBlocker(key))},
getBlocker:function(key,fn){let blocker=state$jscomp$0.blockers.get(key)||IDLE_BLOCKER;blockerFunctions.get(key)!==fn&&blockerFunctions.set(key,fn);return blocker},deleteBlocker,_internalFetchControllers:fetchControllers,_internalActiveDeferreds:activeDeferreds,_internalSetRoutes:function(newRoutes){manifest={};inFlightDataRoutes=convertRoutesToDataRoutes(newRoutes,mapRouteProperties,void 0,manifest)}}};exports.createStaticHandler=function(routes,opts){async function queryImpl(request,location,matches,
requestContext,routeMatch){invariant(request.signal,"query()/queryRoute() requests must contain an AbortController signal");try{if(isMutationMethod(request.method.toLowerCase()))return await submit(request,matches,routeMatch||getTargetMatch(matches,location),requestContext,null!=routeMatch);let result=await loadRouteData(request,matches,requestContext,routeMatch);return isResponse(result)?result:_extends({},result,{actionData:null,actionHeaders:{}})}catch(e){if((request=e)&&isResponse(request.response)&&
(request.type===ResultType.data||request.type===ResultType.error)){if(e.type===ResultType.error)throw e.response;return e.response}location=e;isResponse(location)?(request=location.status,location=location.headers.get("Location"),request=300<=request&&399>=request&&null!=location):request=!1;if(request)return e;throw e;}}async function submit(request,matches,actionMatch,requestContext,isRouteRequest){if(actionMatch.route.action||actionMatch.route.lazy){var result=await callLoaderOrAction("action",
request,actionMatch,matches,manifest,mapRouteProperties,basename,{isStaticRequest:!0,isRouteRequest,requestContext});if(request.signal.aborted)throw Error((isRouteRequest?"queryRoute":"query")+"() call aborted: "+request.method+" "+request.url);}else{result=getInternalRouterError(405,{method:request.method,pathname:(new URL(request.url)).pathname,routeId:actionMatch.route.id});if(isRouteRequest)throw result;result={type:ResultType.error,error:result}}if(isRedirectResult(result))throw new Response(null,
{status:result.status,headers:{Location:result.location}});if(isDeferredResult(result)){result=getInternalRouterError(400,{type:"defer-action"});if(isRouteRequest)throw result;result={type:ResultType.error,error:result}}if(isRouteRequest){if(isErrorResult(result))throw result.error;return{matches:[actionMatch],loaderData:{},actionData:{[actionMatch.route.id]:result.data},errors:null,statusCode:200,loaderHeaders:{},actionHeaders:{},activeDeferreds:null}}if(isErrorResult(result))return isRouteRequest=
findNearestBoundary(matches,actionMatch.route.id),matches=await loadRouteData(request,matches,requestContext,void 0,{[isRouteRequest.route.id]:result.error}),_extends({},matches,{statusCode:isRouteErrorResponse(result.error)?result.error.status:500,actionData:null,actionHeaders:_extends({},result.headers?{[actionMatch.route.id]:result.headers}:{})});request=new Request(request.url,{headers:request.headers,redirect:request.redirect,signal:request.signal});matches=await loadRouteData(request,matches,
requestContext);return _extends({},matches,result.statusCode?{statusCode:result.statusCode}:{},{actionData:{[actionMatch.route.id]:result.data},actionHeaders:_extends({},result.headers?{[actionMatch.route.id]:result.headers}:{})})}async function loadRouteData(request,matches,requestContext,routeMatch,pendingActionError){let isRouteRequest=null!=routeMatch;if(!(!isRouteRequest||null!=routeMatch&&routeMatch.route.loader||null!=routeMatch&&routeMatch.route.lazy))throw getInternalRouterError(400,{method:request.method,
pathname:(new URL(request.url)).pathname,routeId:null==routeMatch?void 0:routeMatch.route.id});routeMatch=(routeMatch?[routeMatch]:getLoaderMatchesUntilBoundary(matches,Object.keys(pendingActionError||{})[0])).filter(m=>m.route.loader||m.route.lazy);if(0===routeMatch.length)return{matches,loaderData:matches.reduce((acc,m)=>Object.assign(acc,{[m.route.id]:null}),{}),errors:pendingActionError||null,statusCode:200,loaderHeaders:{},activeDeferreds:null};let results=await Promise.all([...routeMatch.map(match=>
callLoaderOrAction("loader",request,match,matches,manifest,mapRouteProperties,basename,{isStaticRequest:!0,isRouteRequest,requestContext}))]);if(request.signal.aborted)throw Error((isRouteRequest?"queryRoute":"query")+"() call aborted: "+request.method+" "+request.url);let activeDeferreds=new Map,context=processRouteLoaderData(matches,routeMatch,results,pendingActionError,activeDeferreds),executedLoaders=new Set(routeMatch.map(match=>match.route.id));matches.forEach(match=>{executedLoaders.has(match.route.id)||
(context.loaderData[match.route.id]=null)});return _extends({},context,{matches,activeDeferreds:0<activeDeferreds.size?Object.fromEntries(activeDeferreds.entries()):null})}invariant(0<routes.length,"You must provide a non-empty routes array to createStaticHandler");let manifest={},basename=(opts?opts.basename:null)||"/",mapRouteProperties;if(null!=opts&&opts.mapRouteProperties)mapRouteProperties=opts.mapRouteProperties;else if(null!=opts&&opts.detectErrorBoundary){let detectErrorBoundary=opts.detectErrorBoundary;
mapRouteProperties=route=>({hasErrorBoundary:detectErrorBoundary(route)})}else mapRouteProperties=defaultMapRouteProperties;let dataRoutes=convertRoutesToDataRoutes(routes,mapRouteProperties,void 0,manifest);return{dataRoutes,query:async function(request,_temp3){let {requestContext}=void 0===_temp3?{}:_temp3;_temp3=new URL(request.url);let method=request.method;_temp3=createLocation("",createPath(_temp3),null,"default");let matches=matchRoutes(dataRoutes,_temp3,basename);if(!validRequestMethods.has(method.toLowerCase())&&
"HEAD"!==method){request=getInternalRouterError(405,{method});let {matches:methodNotAllowedMatches,route}=getShortCircuitMatches(dataRoutes);return{basename,location:_temp3,matches:methodNotAllowedMatches,loaderData:{},actionData:null,errors:{[route.id]:request},statusCode:request.status,loaderHeaders:{},actionHeaders:{},activeDeferreds:null}}if(!matches){request=getInternalRouterError(404,{pathname:_temp3.pathname});let {matches:notFoundMatches,route}=getShortCircuitMatches(dataRoutes);return{basename,
location:_temp3,matches:notFoundMatches,loaderData:{},actionData:null,errors:{[route.id]:request},statusCode:request.status,loaderHeaders:{},actionHeaders:{},activeDeferreds:null}}request=await queryImpl(request,_temp3,matches,requestContext);return isResponse(request)?request:_extends({location:_temp3,basename},request)},queryRoute:async function(request,_temp4){let {routeId,requestContext}=void 0===_temp4?{}:_temp4;var url=new URL(request.url);_temp4=request.method;url=createLocation("",createPath(url),
null,"default");let matches=matchRoutes(dataRoutes,url,basename);if(!validRequestMethods.has(_temp4.toLowerCase())&&"HEAD"!==_temp4&&"OPTIONS"!==_temp4)throw getInternalRouterError(405,{method:_temp4});if(!matches)throw getInternalRouterError(404,{pathname:url.pathname});_temp4=routeId?matches.find(m=>m.route.id===routeId):getTargetMatch(matches,url);if(routeId&&!_temp4)throw getInternalRouterError(403,{pathname:url.pathname,routeId});if(!_temp4)throw getInternalRouterError(404,{pathname:url.pathname});
request=await queryImpl(request,url,matches,requestContext,_temp4);if(isResponse(request))return request;url=request.errors?Object.values(request.errors)[0]:void 0;if(void 0!==url)throw url;if(request.actionData)return Object.values(request.actionData)[0];if(request.loaderData){var _result$activeDeferre;url=Object.values(request.loaderData)[0];null!=(_result$activeDeferre=request.activeDeferreds)&&_result$activeDeferre[_temp4.route.id]&&(url[UNSAFE_DEFERRED_SYMBOL]=request.activeDeferreds[_temp4.route.id]);
return url}}}};exports.defer=function(data,init){void 0===init&&(init={});return new DeferredData(data,"number"===typeof init?{status:init}:init)};exports.generatePath=function(originalPath,params){void 0===params&&(params={});var path=originalPath;path.endsWith("*")&&"*"!==path&&!path.endsWith("/*")&&(warning(!1,'Route path "'+path+'" will be treated as if it were "'+(path.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "')+
(path.replace(/\*$/,"/*")+'".')),path=path.replace(/\*$/,"/*"));originalPath=path.startsWith("/")?"/":"";const stringify=p=>null==p?"":"string"===typeof p?p:String(p);path=path.split(/\/+/).map((segment,index,array)=>{if(index===array.length-1&&"*"===segment)return stringify(params["*"]);if(index=segment.match(/^:(\w+)(\??)$/)){const [,key,optional]=index;segment=params[key];invariant("?"===optional||null!=segment,'Missing ":'+key+'" param');return stringify(segment)}return segment.replace(/\?$/g,
"")}).filter(segment=>!!segment);return originalPath+path.join("/")};exports.getStaticContextFromError=function(routes,context,error){return _extends({},context,{statusCode:500,errors:{[context._deepestRenderedBoundaryId||routes[0].id]:error}})};exports.getToPathname=function(to){return""===to||""===to.pathname?"/":"string"===typeof to?parsePath(to).pathname:to.pathname};exports.isDeferredData=isDeferredData;exports.isRouteErrorResponse=isRouteErrorResponse;exports.joinPaths=joinPaths;exports.json=
function(data,init){void 0===init&&(init={});init="number"===typeof init?{status:init}:init;let headers=new Headers(init.headers);headers.has("Content-Type")||headers.set("Content-Type","application/json; charset\x3dutf-8");return new Response(JSON.stringify(data),_extends({},init,{headers}))};exports.matchPath=matchPath;exports.matchRoutes=matchRoutes;exports.normalizePathname=normalizePathname;exports.parsePath=parsePath;exports.redirect=redirect;exports.redirectDocument=(url,init)=>{url=redirect(url,
init);url.headers.set("X-Remix-Reload-Document","true");return url};exports.resolvePath=resolvePath;exports.resolveTo=resolveTo;exports.stripBasename=stripBasename}
//# sourceMappingURL=module$node_modules$$remix_run$router$dist$router_cjs.js.map
